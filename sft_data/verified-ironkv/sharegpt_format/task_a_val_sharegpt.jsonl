{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires old(netc).ok(), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (,\nensures netc.my_end_point() == old(netc).my_end_point(), (,"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_flatten_sets_union_auto<A>()\n    ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)) by {\n        lemma_flatten_sets_union(sets1, sets2);\n    }\n}\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>| #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nexec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      \n        res.is_marshalable(),\n        start <= mid <= end <= data@.len(),\n        data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@),\n        res@.len() == i,\n        len.ghost_serialize().len() +\n          res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start,\n        accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "invariant 0 <= i <= len,"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn empty_key_range_is_consistent(&self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, id: &ID)\n        requires\n            lo.geq_spec(*hi),\n        \n    {\n        K::cmp_properties();\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires lo.geq_spec(*hi), ensures self.range_consistent(lo, hi, id),\nensures self.range_consistent(lo, hi, id),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n    {\n    assert_sets_equal!(s.push(x).to_set() == s.to_set().insert(x), elem => {\n        if elem == x {\n            assert(s.push(x)[s.len() as int] == x);\n            assert(s.push(x).contains(x))\n        } else {\n            if s.to_set().insert(x).contains(elem) {\n                assert(s.to_set().contains(elem));\n                let i = choose |i: int| 0 <= i < s.len() && s[i] == elem;\n                assert(s.push(x)[i] == elem);\n            }\n        }\n    });\n}\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures s.push(x).to_set() == s.to_set().insert(x),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        {\n      CKeyHashMap { m: collections::HashMap::new() }\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures out@ == Map::<AbstractKey, Seq<u8>>::empty(),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n         rc),\n    {\n        self.real_next_impl(netc)\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn view_equal_spec()\n    {\n    assert forall |x: &CMessage, y: &CMessage|\n      #[trigger] x.view_equal(y) <==> x@ == y@ by\n    {\n      match (x, y) {\n        (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {},\n        (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {},\n        (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {},\n        (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {},\n        (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {},\n        (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {},\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@,"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires self.valid(), ensures s == self@.to_set(), s.finite(), s.len() == self@.len(),\nensures s == self@.to_set(), s.finite(), s.len() == self@.len(),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_up_to_view(&self) -> (res: EndPoint)\n        {\n        EndPoint{id: clone_vec_u8(&self.id)}\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures res@ == self@,"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires true, // ensures o == self.cmp_spec(*other),\nensures o == self.cmp_spec(*other),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn map_set_finite_auto<A, B>()\n\n{\n    assert forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() implies #[trigger] s.map(f).finite() by {\n        map_finite(s, f);\n    }\n}\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n        {\n        panic!()\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures b == valid_hashtable(self@),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires self.valid(), ensures id@ == self@[*k], id@.valid_physical_address(),\nensures id@ == self@[*k], id@.valid_physical_address(),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n   start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "requires 0 <= start <= s.len(), 0 <= midsize <= endsize <= s.len() - start, ensures s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\nensures s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn view_equal_spec()\n            {\n        }\n```\n\nWrite the specifications:"}, {"from": "gpt", "value": "ensures forall |x: &SHTKey, y: &SHTKey| #[trigger] x.view_equal(y) <==> x == y,"}]}
