{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        \n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        requires\n            from_trusted_code()\n    {\n        (self.c_pointers.get_time_func)()\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        \n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n    {\n        let result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n    {\n        let result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        \n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n        ensures\n            self@.un_acked_messages_for_dest_up_to(src, dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        requires\n            self@.send_state.contains_key(dst),\n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n        ensures\n            self@.un_acked_messages_for_dest_up_to(src, dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: &EndPoint, value: V)\n       value)\n    {\n      let key_clone: EndPoint = key.clone_up_to_view();\n      self.m.insert(key_clone, value);\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: &EndPoint, value: V)\n      ensures self@ == old(self)@.insert(key@, value)\n    {\n      let key_clone: EndPoint = key.clone_up_to_view();\n      self.m.insert(key_clone, value);\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn seq_map_values_concat_auto<A, B>()\n f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\npub proof fn seq_map_values_concat_auto<A, B>()\nensures forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n         dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n        requires dests == Set::<AbstractEndPoint>::empty()\n        ensures self.un_acked_messages_for_dests(src, dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            },\n    {\n        let mut i = 0;\n        while i < self.keys.len()\n            invariant forall |j| 0 <= j < i ==> self.keys@[j] != k,\n            decreases self.keys@.len() - i\n        {\n            //println!(\"Loop {} of find_key\", i);\n            if self.keys.index(i).cmp(&k).is_eq() {\n                proof {\n                    K::cmp_properties();\n                }\n                return Some(i);\n            } else {\n                proof {\n                    K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        return None;\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            },\n    {\n        let mut i = 0;\n        while i < self.keys.len()\n            invariant forall |j| 0 <= j < i ==> self.keys@[j] != k,\n            decreases self.keys@.len() - i\n        {\n            //println!(\"Loop {} of find_key\", i);\n            if self.keys.index(i).cmp(&k).is_eq() {\n                proof {\n                    K::cmp_properties();\n                }\n                return Some(i);\n            } else {\n                proof {\n                    K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        return None;\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn set_map_union_auto<A, B>()\n     f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map(f)) == s1.map(f) + s2.map(f) by {\n        set_map_union(s1, s2, f);\n    }\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\npub proof fn set_map_union_auto<A, B>()\n    ensures forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map(f)) == s1.map(f) + s2.map(f) by {\n        set_map_union(s1, s2, f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            },\n            // TODO: capture the part of send_single_message when should_send == false\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            },\n            // TODO: capture the part of send_single_message when should_send == false\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        let lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    proof fn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        let lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        \n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        ensures\n            ep@ == self.my_end_point()\n    {\n        self.end_point.clone_up_to_view()\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n right);\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            },\n            // TODO: capture the part of send_single_message when should_send == false\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            },\n            // TODO: capture the part of send_single_message when should_send == false\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n         KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        \n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            },\n    {\n        let mut i = 0;\n        while i < self.keys.len()\n            invariant forall |j| 0 <= j < i ==> self.keys@[j] != k,\n            decreases self.keys@.len() - i\n        {\n            //println!(\"Loop {} of find_key\", i);\n            if self.keys.index(i).cmp(&k).is_eq() {\n                proof {\n                    K::cmp_properties();\n                }\n                return Some(i);\n            } else {\n                proof {\n                    K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        return None;\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            },\n    {\n        let mut i = 0;\n        while i < self.keys.len()\n            invariant forall |j| 0 <= j < i ==> self.keys@[j] != k,\n            decreases self.keys@.len() - i\n        {\n            //println!(\"Loop {} of find_key\", i);\n            if self.keys.index(i).cmp(&k).is_eq() {\n                proof {\n                    K::cmp_properties();\n                }\n                return Some(i);\n            } else {\n                proof {\n                    K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        return None;\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n     rc),\n    {\n        Self::real_init_impl(netc, args)\n    }\n\n//    spec fn parse_command_line_configuration(args:Seq<Seq<u8>>) -> CC;\n\n//    spec fn concrete_config_init(cc: CC) -> bool;\n//    spec fn concrete_config_to_servers(cc: CC) -> Set<EndPoint>;\n\n    pub open spec fn next_requires(self, netc: NetClient) -> bool\n    {\n        &&& self.invariants(&netc.my_end_point())\n        &&& netc.state() is Receiving    // new wrt ironfleet because we're encoding reduction rules in NetClient interface instead of by reading the history.\n    }\n\n    pub open spec fn next_ensures(old_self: Self, old_netc: NetClient, new_self: Self, new_netc: NetClient, rc: (bool, Ghost<EventResults>)) -> bool\n    {\n        let (ok, res) = rc; {\n            &&& ok == new_netc.ok()\n            &&& ok ==> new_self.invariants(&new_netc.my_end_point())\n            &&& ok ==> Self::next(old_self.view(), new_self.view(), res@.ios)\n            &&& ok ==> res@.event_seq() == res@.ios\n            &&& (ok || res@.sends.len()>0) ==> new_netc.history() == old_netc.history() + res@.event_seq()\n            &&& res@.well_typed_events()\n        }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n    ensures\n        Self::init_ensures(netc, *args, rc),\n    {\n        Self::real_init_impl(netc, args)\n    }\n\n//    spec fn parse_command_line_configuration(args:Seq<Seq<u8>>) -> CC;\n\n//    spec fn concrete_config_init(cc: CC) -> bool;\n//    spec fn concrete_config_to_servers(cc: CC) -> Set<EndPoint>;\n\n    pub open spec fn next_requires(self, netc: NetClient) -> bool\n    {\n        &&& self.invariants(&netc.my_end_point())\n        &&& netc.state() is Receiving    // new wrt ironfleet because we're encoding reduction rules in NetClient interface instead of by reading the history.\n    }\n\n    pub open spec fn next_ensures(old_self: Self, old_netc: NetClient, new_self: Self, new_netc: NetClient, rc: (bool, Ghost<EventResults>)) -> bool\n    {\n        let (ok, res) = rc; {\n            &&& ok == new_netc.ok()\n            &&& ok ==> new_self.invariants(&new_netc.my_end_point())\n            &&& ok ==> Self::next(old_self.view(), new_self.view(), res@.ios)\n            &&& ok ==> res@.event_seq() == res@.ios\n            &&& (ok || res@.sends.len()>0) ==> new_netc.history() == old_netc.history() + res@.event_seq()\n            &&& res@.well_typed_events()\n        }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        \n    {\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\nfn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\n\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n   midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\n\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\nensures\n    out@ == arg@\n{\n    clone_vec_u8(arg)\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n  pub fn clone_up_to_view(&self) -> (c: Self)\n   dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_to_set_singleton_auto<A>()\n\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}"}]}
