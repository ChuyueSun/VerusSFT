{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n    requires 0 <= i <= j <= k <= s.len(),\n    ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nassert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn set(&mut self, k: K, v: ID)\n    requires old(self).valid(),\n    ensures self.valid(), self@ == old(self)@.insert(k, v), forall |lo, hi| self.gap(lo, hi) <==> old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nmatch self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<()\n    requires !(old(self).state() is Error),\n    ensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}],\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nlet result: Result<(), IronfleetIOError> = self.send_internal_wrapper(recipient, message);\n        match result {\n            Ok(_) => {\n                self.state = Ghost(State::Sending{});\n                self.history = Ghost(self.history@ + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}]);\n            }\n            Err(_) => {\n                self.state = Ghost(State::Error{});\n            }\n        };\n        result\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external)]\n#[verifier(external)]\npub fn get_time_internal(&self) -> (time: u64)\n    requires from_trusted_code(),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\n(self.c_pointers.get_time_func)()\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n    ensures eq == (e1@ == e2@),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nif e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires 0 <= i <= cm.len(),\n    ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i,\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nif 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn truncate(&mut self, seqno_acked: u64, Ghost(dst)\n    requires old(self).valid(dst), old(self).num_packets_acked <= seqno_acked,\n    ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nlet mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn new() -> (v: Self)\n    ensures v@ == Seq::<K>::empty(), v.valid(),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nStrictlyOrderedVec { v: Vec::new() }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\n    requires x@ == y@,\n    ensures x.is_marshalable() == y.is_marshalable(),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nCSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n    requires self.valid(), 0 <= lo <= hi < self.lows.keys@.len(), forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n    ensures self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n    decreases hi - lo,\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nlet lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n    ensures present == abstractify_end_points(*endpoints).contains(endpoint@),\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nlet mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nexecfn _is_marshalable(&self) -> bool\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nlet mut res = true;\n    let mut i = 0;\n    let mut total_len = self.len().serialized_size();\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while res && i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        res ==> total_len as int == (self@.len() as usize).ghost_serialize().len() +\n                 self@.subrange(0, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n        res ==> (forall |x: T| self@.subrange(0, i as int).contains(x) ==> #[trigger] x.is_marshalable()),\n        res ==> total_len as int <= usize::MAX,\n        !res ==> !self.is_marshalable(),\n      decreases\n        self.len() - i + if res { 1int } else { 0int }\n    {\n      assert(res);\n      res = res && self[i]._is_marshalable() && (usize::MAX - total_len >= self[i].serialized_size());\n      if res {\n        let old_total_len = total_len;\n        total_len = total_len + self[i].serialized_size();\n        i = i + 1;\n        proof {\n          assert forall |x: T| #[trigger] self@.subrange(0, i as int).contains(x) implies x.is_marshalable() by {\n            if (exists |j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x) {\n              let j = choose|j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x;\n              assert(self@.subrange(0, i as int - 1)[j] == x); // OBSERVE\n            }\n          };\n          let sl = |x: T| x.ghost_serialize().len() as int;\n          assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n          let s = self@.subrange(0 as int, i as int);\n          seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n          assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n        }\n      } else {\n        proof {\n          if usize::MAX < total_len + self@[i as int].ghost_serialize().len() {\n            assert(\n              ((self@.len() as usize).ghost_serialize().len() +\n               self@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()))\n                >=\n              (total_len + self@[i as int].ghost_serialize().len())\n            ) by {\n              let f = |x: T| x.ghost_serialize();\n              let sl = |x: T| x.ghost_serialize().len() as int;\n              let s = self@.subrange(0 as int, i as int + 1);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n              seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n              assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i as int));\n              seq_lib_v::lemma_seq_fold_left_append_len_int_le(self@, i as int + 1, 0, f);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + f(x).len()));\n            };\n          } else {\n            assert(!self@[i as int].is_marshalable());\n          }\n        }\n      }\n    }\n\n    res\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n    requires old(self).state() is Receiving,\n    ensures self.my_end_point() == old(self).my_end_point(), match result { NetcReceiveResult::Received{sender, message} => { &&& self.state() is Receiving &&& sender.abstractable() &&& self.history() == old(self).history() + seq![ LIoOp::Receive{ r: LPacket{ dst: self.my_end_point(), src: sender@, msg: message@} }] } NetcReceiveResult::TimedOut{} => { &&& self.state() is Sending &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}] } NetcReceiveResult::Error{} => { self.state() is Error } },\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nlet result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n    ensures value == match Self::get_spec(self@, key@) { Some(v) => Some(&v), None => None },\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nmatch self.m.get(&key) {\n        std::option::Option::Some(v) => Some(v),\n        std::option::Option::None => None,\n      }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn view_equal_spec()\n    ensures forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ { assert forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by { match (x, y) { (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, }, CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => { CMessage::view_equal_spec(); assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2); assert(dst1.view_equal(dst2) <==> dst1@ == dst2@); assert(m1.view_equal(m2) <==> m1@ == m2@); } (CSingleMessage::InvalidMessage { }, CSingleMessage::InvalidMessage { }) => {} (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {} _ => { assert(!x.view_equal(y) && x@ != y@); } } } } pub fn clone_up_to_view(&self) -> (c: Self) ensures c@ == self@,\n    ensures c@ == self@,\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nmatch self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n    requires self.valid(dst), 0 <= k < self.un_acked@.len(),\n    ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1,\n    decreases k,\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nif k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"from": "human", "value": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n    ensures cloned_ep@ == ep@,\n```\n\nImplement the function body:"}, {"from": "gpt", "value": "{\nEndPoint{id: clone_vec_u8(&ep.id)}\n}"}]}
