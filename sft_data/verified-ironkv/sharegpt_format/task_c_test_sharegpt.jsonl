{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn new(k: K) -> (s: Self)\n        \n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    pub fn new(k: K) -> (s: Self)\n        ensures s.k == Some(k)\n    {\n        KeyIterator { k: Some(k) }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn len(&self) -> (len: usize )\n        \n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    fn len(&self) -> (len: usize )\n        ensures len == self@.len()\n    {\n        self.v.len()\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        \n    {\n        self.k.as_ref().unwrap()\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n        ensures\n            match ov {\n                Some(e1) => res.is_some() && e1@ == res->0@,\n                None => res is None,\n            }\n    {\n        match ov {\n            Some(e1) => Some(clone_vec_u8(e1)),\n            None => None,\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n        ensures\n            match ov {\n                Some(e1) => res.is_some() && e1@ == res->0@,\n                None => res is None,\n            }\n    {\n        match ov {\n            Some(e1) => Some(clone_vec_u8(e1)),\n            None => None,\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn new() -> (e: CAckState)\n    ensures\n        e.num_packets_acked == 0,\n        e.un_acked.len() == 0,\n        e@ =~= AckState::new(),\n    {\n         CAckState{ num_packets_acked: 0, un_acked: vec![] }\n//         let e = CAckState{ num_packets_acked: 0, un_acked: vec![] };\n//         assert( e@.num_packets_acked  == AckState::new().num_packets_acked );\n//         assert( e@.un_acked  =~= AckState::new().un_acked );\n//         e\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn new() -> (e: CAckState)\n    ensures\n        e.num_packets_acked == 0,\n        e.un_acked.len() == 0,\n        e@ =~= AckState::new(),\n    {\n         CAckState{ num_packets_acked: 0, un_acked: vec![] }\n//         let e = CAckState{ num_packets_acked: 0, un_acked: vec![] };\n//         assert( e@.num_packets_acked  == AckState::new().num_packets_acked );\n//         assert( e@.un_acked  =~= AckState::new().un_acked );\n//         e\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn cmp_properties()\n//        ensures\n//        // Equality is eq  --- TODO: Without this we need to redefine Seq, Set, etc. operators that use ==\n//        forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(),\n//        // Reflexivity of equality\n//        forall |a:Self| #![auto] a.cmp_spec(a).eq(),\n//        // Commutativity of equality\n//        forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(),\n//        // Transitivity of equality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(),\n//        // Inequality is asymmetric\n//        forall |a:Self, b:Self|\n//            #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(),\n//        // Connected\n//        forall |a:Self, b:Self|\n//            #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(),\n//        // Transitivity of inequality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()\n    {\n    }\n\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    proof fn cmp_properties()\n//        ensures\n//        // Equality is eq  --- TODO: Without this we need to redefine Seq, Set, etc. operators that use ==\n//        forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(),\n//        // Reflexivity of equality\n//        forall |a:Self| #![auto] a.cmp_spec(a).eq(),\n//        // Commutativity of equality\n//        forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(),\n//        // Transitivity of equality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(),\n//        // Inequality is asymmetric\n//        forall |a:Self, b:Self|\n//            #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(),\n//        // Connected\n//        forall |a:Self, b:Self|\n//            #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(),\n//        // Transitivity of inequality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()\n    {\n    }\n\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n         sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n        ensures  self.next_get_request_postconditions(*old(self), sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n  exec fn _is_marshalable(&self) -> bool {\n    let mut res = true;\n    let mut i = 0;\n    let mut total_len = self.len().serialized_size();\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while res && i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        res ==> total_len as int == (self@.len() as usize).ghost_serialize().len() +\n                 self@.subrange(0, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n        res ==> (forall |x: T| self@.subrange(0, i as int).contains(x) ==> #[trigger] x.is_marshalable()),\n        res ==> total_len as int <= usize::MAX,\n        !res ==> !self.is_marshalable(),\n      decreases\n        self.len() - i + if res { 1int } else { 0int }\n    {\n      assert(res);\n      res = res && self[i]._is_marshalable() && (usize::MAX - total_len >= self[i].serialized_size());\n      if res {\n        let old_total_len = total_len;\n        total_len = total_len + self[i].serialized_size();\n        i = i + 1;\n        proof {\n          assert forall |x: T| #[trigger] self@.subrange(0, i as int).contains(x) implies x.is_marshalable() by {\n            if (exists |j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x) {\n              let j = choose|j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x;\n              assert(self@.subrange(0, i as int - 1)[j] == x); // OBSERVE\n            }\n          };\n          let sl = |x: T| x.ghost_serialize().len() as int;\n          assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n          let s = self@.subrange(0 as int, i as int);\n          seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n          assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n        }\n      } else {\n        proof {\n          if usize::MAX < total_len + self@[i as int].ghost_serialize().len() {\n            assert(\n              ((self@.len() as usize).ghost_serialize().len() +\n               self@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()))\n                >=\n              (total_len + self@[i as int].ghost_serialize().len())\n            ) by {\n              let f = |x: T| x.ghost_serialize();\n              let sl = |x: T| x.ghost_serialize().len() as int;\n              let s = self@.subrange(0 as int, i as int + 1);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n              seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n              assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i as int));\n              seq_lib_v::lemma_seq_fold_left_append_len_int_le(self@, i as int + 1, 0, f);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + f(x).len()));\n            };\n          } else {\n            assert(!self@[i as int].is_marshalable());\n          }\n        }\n      }\n    }\n\n    res\n  }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n  exec fn _is_marshalable(&self) -> bool {\n    let mut res = true;\n    let mut i = 0;\n    let mut total_len = self.len().serialized_size();\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while res && i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        res ==> total_len as int == (self@.len() as usize).ghost_serialize().len() +\n                 self@.subrange(0, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n        res ==> (forall |x: T| self@.subrange(0, i as int).contains(x) ==> #[trigger] x.is_marshalable()),\n        res ==> total_len as int <= usize::MAX,\n        !res ==> !self.is_marshalable(),\n      decreases\n        self.len() - i + if res { 1int } else { 0int }\n    {\n      assert(res);\n      res = res && self[i]._is_marshalable() && (usize::MAX - total_len >= self[i].serialized_size());\n      if res {\n        let old_total_len = total_len;\n        total_len = total_len + self[i].serialized_size();\n        i = i + 1;\n        proof {\n          assert forall |x: T| #[trigger] self@.subrange(0, i as int).contains(x) implies x.is_marshalable() by {\n            if (exists |j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x) {\n              let j = choose|j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x;\n              assert(self@.subrange(0, i as int - 1)[j] == x); // OBSERVE\n            }\n          };\n          let sl = |x: T| x.ghost_serialize().len() as int;\n          assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n          let s = self@.subrange(0 as int, i as int);\n          seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n          assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n        }\n      } else {\n        proof {\n          if usize::MAX < total_len + self@[i as int].ghost_serialize().len() {\n            assert(\n              ((self@.len() as usize).ghost_serialize().len() +\n               self@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()))\n                >=\n              (total_len + self@[i as int].ghost_serialize().len())\n            ) by {\n              let f = |x: T| x.ghost_serialize();\n              let sl = |x: T| x.ghost_serialize().len() as int;\n              let s = self@.subrange(0 as int, i as int + 1);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n              seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n              assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i as int));\n              seq_lib_v::lemma_seq_fold_left_append_len_int_le(self@, i as int + 1, 0, f);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + f(x).len()));\n            };\n          } else {\n            assert(!self@[i as int].is_marshalable());\n          }\n        }\n      }\n    }\n\n    res\n  }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\npub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\n\n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "pub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\nensures\n    out@ == v@\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n        invariant\n            i <= v.len(),\n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn empty() -> (out:Self)\n    \n            send_state: CSendState{epmap: HashMap::new()},\n        };\n        proof {\n            assert_maps_equal!(result.receive_state@, SingleDelivery::<Message>::init().receive_state);\n            assert_maps_equal!(result.send_state@, SingleDelivery::<Message>::init().send_state);\n        }\n        result\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn empty() -> (out:Self)\n    ensures out@ == SingleDelivery::<Message>::init()\n    {\n        let result = CSingleDelivery {\n            receive_state: CTombstoneTable{epmap: HashMap::new()},\n            send_state: CSendState{epmap: HashMap::new()},\n        };\n        proof {\n            assert_maps_equal!(result.receive_state@, SingleDelivery::<Message>::init().receive_state);\n            assert_maps_equal!(result.send_state@, SingleDelivery::<Message>::init().send_state);\n        }\n        result\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n    pub fn clone_up_to_view(&self) -> (o:Self)\n        ensures o@ == self@\n    {\n        let mut un_acked: Vec<CSingleMessage> = Vec::new();\n        let mut i = 0;\n        while i < self.un_acked.len()\n            invariant\n                i <= self.un_acked.len(),\n                un_acked@.len() == i as nat,\n                forall |j: int| 0 <= j < i as nat ==> #[trigger] (un_acked@[j]@) == self.un_acked@[j]@\n            decreases\n                self.un_acked.len() - i\n        {\n            un_acked.push(self.un_acked[i].clone_up_to_view());\n            i = i + 1;\n        }\n        proof {\n            assert_seqs_equal!(abstractify_cmessage_seq(un_acked@) == abstractify_cmessage_seq(self.un_acked@));\n        }\n        CAckState {\n            num_packets_acked: self.num_packets_acked,\n            un_acked,\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn clone_up_to_view(&self) -> (o:Self)\n        ensures o@ == self@\n    {\n        let mut un_acked: Vec<CSingleMessage> = Vec::new();\n        let mut i = 0;\n        while i < self.un_acked.len()\n            invariant\n                i <= self.un_acked.len(),\n                un_acked@.len() == i as nat,\n                forall |j: int| 0 <= j < i as nat ==> #[trigger] (un_acked@[j]@) == self.un_acked@[j]@\n            decreases\n                self.un_acked.len() - i\n        {\n            un_acked.push(self.un_acked[i].clone_up_to_view());\n            i = i + 1;\n        }\n        proof {\n            assert_seqs_equal!(abstractify_cmessage_seq(un_acked@) == abstractify_cmessage_seq(self.un_acked@));\n        }\n        CAckState {\n            num_packets_acked: self.num_packets_acked,\n            un_acked,\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn clone_up_to_view(&self) -> (o:Self)\n        \n                un_acked@.len() == i as nat,\n                forall |j: int| 0 <= j < i as nat ==> #[trigger] (un_acked@[j]@) == self.un_acked@[j]@\n            decreases\n                self.un_acked.len() - i\n        {\n            un_acked.push(self.un_acked[i].clone_up_to_view());\n            i = i + 1;\n        }\n        proof {\n            assert_seqs_equal!(abstractify_cmessage_seq(un_acked@) == abstractify_cmessage_seq(self.un_acked@));\n        }\n        CAckState {\n            num_packets_acked: self.num_packets_acked,\n            un_acked,\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn clone_up_to_view(&self) -> (o:Self)\n        ensures o@ == self@\n    {\n        let mut un_acked: Vec<CSingleMessage> = Vec::new();\n        let mut i = 0;\n        while i < self.un_acked.len()\n            invariant\n                i <= self.un_acked.len(),\n                un_acked@.len() == i as nat,\n                forall |j: int| 0 <= j < i as nat ==> #[trigger] (un_acked@[j]@) == self.un_acked@[j]@\n            decreases\n                self.un_acked.len() - i\n        {\n            un_acked.push(self.un_acked[i].clone_up_to_view());\n            i = i + 1;\n        }\n        proof {\n            assert_seqs_equal!(abstractify_cmessage_seq(un_acked@) == abstractify_cmessage_seq(self.un_acked@));\n        }\n        CAckState {\n            num_packets_acked: self.num_packets_acked,\n            un_acked,\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n  pub fn is_marshallable(&self) -> (b: bool)\n      \n          CSingleMessage::Message{seqno, dst, m} => dst.valid_physical_address() && m.is_message_marshallable(),\n          CSingleMessage::InvalidMessage{} => false,\n      }\n  }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "  pub fn is_marshallable(&self) -> (b: bool)\n      ensures b == self.marshallable()\n  {\n      match self {\n          CSingleMessage::Ack{ack_seqno} => true,\n          CSingleMessage::Message{seqno, dst, m} => dst.valid_physical_address() && m.is_message_marshallable(),\n          CSingleMessage::InvalidMessage{} => false,\n      }\n  }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn contains_exec(&self, k: &K) -> (b: bool)\n    \n    {\n        let ki = KeyIterator { k: Some(k.clone()) };\n        !ki.lt(&self.lo) && ki.lt(&self.hi)\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn contains_exec(&self, k: &K) -> (b: bool)\n    ensures\n        b == self.contains(*k),\n    {\n        let ki = KeyIterator { k: Some(k.clone()) };\n        !ki.lt(&self.lo) && ki.lt(&self.hi)\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn put(&mut self, src: &EndPoint, value: CAckState)\n     self.epmap@, src@, value),\n    {\n        self.epmap.put(src, value)\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn put(&mut self, src: &EndPoint, value: CAckState)\n    ensures\n        HashMap::put_spec(old(self).epmap@, self.epmap@, src@, value),\n    {\n        self.epmap.put(src, value)\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn host_model_next_receive_message(&mut self) -> (sent_packets: Vec<CPacket>)\n         ..} =>\n                              match m {\n                                  CMessage::GetRequest{..} => old_self.next_get_request_preconditions(),\n                                  CMessage::SetRequest{..} => old_self.next_set_request_preconditions(),\n                                  CMessage::Delegate{..} => old_self.next_delegate_preconditions(),\n                                  CMessage::Shard{..} => old_self.next_shard_preconditions(),\n                                  _ => true,\n                              }\n                          _ => false,\n                      }\n                },\n                None => false,\n            }\n        }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn host_model_next_receive_message(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires ({\n            let old_self = *old(self);\n            match old_self.received_packet {\n                Some(cpacket) => {\n                    &&& old(self).sd.valid()\n                    &&& old(self).host_state_common_preconditions()\n                    &&& match cpacket.msg {\n                          CSingleMessage::Message{m: m, ..} =>\n                              match m {\n                                  CMessage::GetRequest{..} => old_self.next_get_request_preconditions(),\n                                  CMessage::SetRequest{..} => old_self.next_set_request_preconditions(),\n                                  CMessage::Delegate{..} => old_self.next_delegate_preconditions(),\n                                  CMessage::Shard{..} => old_self.next_shard_preconditions(),\n                                  _ => true,\n                              }\n                          _ => false,\n                      }\n                },\n                None => false,\n            }\n        }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n         &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        \n    {\n        self.mind_the_gap();\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            \n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        ensures\n            match oep {\n                Some(ep) => cloned_oep.is_some() && ep@ == cloned_oep->0@,\n                None => cloned_oep is None,\n            }\n    {\n        match oep.as_ref() {\n            Some(ep) => Some(clone_end_point(ep)),\n            None => None\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        ensures\n            match oep {\n                Some(ep) => cloned_oep.is_some() && ep@ == cloned_oep->0@,\n                None => cloned_oep is None,\n            }\n    {\n        match oep.as_ref() {\n            Some(ep) => Some(clone_end_point(ep)),\n            None => None\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    #[verifier(external_body)]\n    #[verifier(when_used_as_spec(spec_from_vec))]\n    pub fn from_vec(v: Vec<CKeyKV>) -> (res: Self)\n       v } in v {\n            res.insert(k, v);\n        }\n        res\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    #[verifier(external_body)]\n    #[verifier(when_used_as_spec(spec_from_vec))]\n    pub fn from_vec(v: Vec<CKeyKV>) -> (res: Self)\n      ensures res == Self::spec_from_vec(v)\n    {\n        let mut res = CKeyHashMap::new();\n        for CKeyKV { k, v } in v {\n            res.insert(k, v);\n        }\n        res\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    fn parse_end_points(args: &Args) -> (out: Option<Vec<EndPoint>>)\n    ensures\n        match out {\n            None => host_protocol_t::parse_args(abstractify_args(*args)) is None,\n            Some(vec) => {\n                &&& host_protocol_t::parse_args(abstractify_args(*args)) is Some\n                &&& abstractify_end_points(vec) == host_protocol_t::parse_args(abstractify_args(*args)).unwrap()\n            },\n        }\n    {\n        let mut end_points: Vec<EndPoint> = Vec::new();\n        let mut i: usize = 0;\n\n        while i<args.len()\n          invariant\n            i <= args.len(),\n            end_points.len() == i,\n            forall |j| #![auto] 0 <= j < i ==> parse_arg_as_end_point(abstractify_args(*args)[j]) == end_points@[j]@,\n            forall |j| #![auto] 0 <= j < i ==> end_points@[j]@.valid_physical_address(),\n          decreases\n            args.len() - i\n        {\n            let end_point = Self::parse_end_point(&(*args)[i]);\n            if !end_point.valid_physical_address() {\n                assert(!unchecked_parse_args(abstractify_args(*args))[i as int].valid_physical_address()); // witness to !forall\n                return None;\n            }\n            end_points.push(end_point);\n            i = i + 1;\n        }\n\n        proof {\n            assert_seqs_equal!(abstractify_end_points(end_points), unchecked_parse_args(abstractify_args(*args)));\n        }\n        Some(end_points)\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn parse_end_points(args: &Args) -> (out: Option<Vec<EndPoint>>)\n    ensures\n        match out {\n            None => host_protocol_t::parse_args(abstractify_args(*args)) is None,\n            Some(vec) => {\n                &&& host_protocol_t::parse_args(abstractify_args(*args)) is Some\n                &&& abstractify_end_points(vec) == host_protocol_t::parse_args(abstractify_args(*args)).unwrap()\n            },\n        }\n    {\n        let mut end_points: Vec<EndPoint> = Vec::new();\n        let mut i: usize = 0;\n\n        while i<args.len()\n          invariant\n            i <= args.len(),\n            end_points.len() == i,\n            forall |j| #![auto] 0 <= j < i ==> parse_arg_as_end_point(abstractify_args(*args)[j]) == end_points@[j]@,\n            forall |j| #![auto] 0 <= j < i ==> end_points@[j]@.valid_physical_address(),\n          decreases\n            args.len() - i\n        {\n            let end_point = Self::parse_end_point(&(*args)[i]);\n            if !end_point.valid_physical_address() {\n                assert(!unchecked_parse_args(abstractify_args(*args))[i as int].valid_physical_address()); // witness to !forall\n                return None;\n            }\n            end_points.push(end_point);\n            i = i + 1;\n        }\n\n        proof {\n            assert_seqs_equal!(abstractify_end_points(end_points), unchecked_parse_args(abstractify_args(*args)));\n        }\n        Some(end_points)\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n     ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn process_received_packet_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n     *old(netc)),\n    ensures ({\n        let (ok, res) = rc;\n        &&& ok == netc.ok()\n        &&& (*self).invariants(&netc.my_end_point())\n        &&& ok ==> {\n            ||| process_received_packet_next((*old(self))@, (*self)@, abstractify_raw_log_to_ios(res@.ios))\n            ||| ignore_nonsensical_delegation_packet((*old(self))@, (*self)@, abstractify_raw_log_to_ios(res@.ios))\n            }\n        &&& self.constants == (*old(self)).constants\n        &&& ok ==> res@.event_seq() == res@.ios\n        &&& ok || (res@.sends.len()>0) ==> (*netc).history() == (*old(netc)).history() + res@.event_seq()\n        &&& res@.well_typed_events()\n        &&& no_invalid_sends(abstractify_raw_log_to_ios(res@.ios))\n        }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "    fn process_received_packet_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures ({\n        let (ok, res) = rc;\n        &&& ok == netc.ok()\n        &&& (*self).invariants(&netc.my_end_point())\n        &&& ok ==> {\n            ||| process_received_packet_next((*old(self))@, (*self)@, abstractify_raw_log_to_ios(res@.ios))\n            ||| ignore_nonsensical_delegation_packet((*old(self))@, (*self)@, abstractify_raw_log_to_ios(res@.ios))\n            }\n        &&& self.constants == (*old(self)).constants\n        &&& ok ==> res@.event_seq() == res@.ios\n        &&& ok || (res@.sends.len()>0) ==> (*netc).history() == (*old(netc)).history() + res@.event_seq()\n        &&& res@.well_typed_events()\n        &&& no_invalid_sends(abstractify_raw_log_to_ios(res@.ios))\n        }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    \n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }"}]}
{"conversations": [{"from": "system", "value": "You are an expert in Verus verification. Given code with a verification error, fix the code to make it verify successfully. Focus on adding or correcting specifications, invariants, or proof blocks."}, {"from": "human", "value": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let s = u64_to_le_bytes(*self);\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i as int));\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < 8\n      invariant\n        0 <= i <= 8,\n        s.len() == 8,\n        s@ == self.ghost_serialize(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i as int),\n        data@.len() == old(data)@.len() + i as int,\n      decreases\n        8 - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i as int));\n\n      let x: u8 = s[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i as int)) by {\n          assert(self.ghost_serialize().subrange(0, (i - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i as int));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i as int) =~= self.ghost_serialize());\n    }\n  }\n```\n\nProvide the fixed code:"}, {"from": "gpt", "value": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let s = u64_to_le_bytes(*self);\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i as int));\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < 8\n      invariant\n        0 <= i <= 8,\n        s.len() == 8,\n        s@ == self.ghost_serialize(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i as int),\n        data@.len() == old(data)@.len() + i as int,\n      decreases\n        8 - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i as int));\n\n      let x: u8 = s[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i as int)) by {\n          assert(self.ghost_serialize().subrange(0, (i - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i as int));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i as int) =~= self.ghost_serialize());\n    }\n  }"}]}
