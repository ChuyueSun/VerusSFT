{"id": "task_b_single_delivery_state_v_get_11", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    ensures value == match HashMap::get_spec(self.epmap@, src@),\n```\n\nImplement the function body:", "target_text": "{\nSome(v) => Some(&v), None => None\n}", "full_function": "\n    pub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    ensures\n        value == match HashMap::get_spec(self.epmap@, src@) { Some(v) => Some(&v), None => None }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "get", "function_mode": "exec", "line_start": 272, "line_end": 275, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 1, "complexity_score": 2, "is_method": true, "impl_type": "CSendState"}}
{"id": "task_b_single_delivery_state_v_put_13", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn put(&mut self, src: &EndPoint, value: CAckState)\n    ensures HashMap::put_spec(old(self).epmap@, self.epmap@, src@, value),\n```\n\nImplement the function body:", "target_text": "{\nself.epmap.put(src, value)\n}", "full_function": "\n    pub fn put(&mut self, src: &EndPoint, value: CAckState)\n    ensures\n        HashMap::put_spec(old(self).epmap@, self.epmap@, src@, value),\n    {\n        self.epmap.put(src, value)\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "put", "function_mode": "exec", "line_start": 292, "line_end": 298, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "CSendState"}}
{"id": "task_b_host_impl_v_host_model_next_set_request_92", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n    requires old(self).next_set_request_preconditions() ensures self.next_set_request_postconditions(*old(self), sent_packets@),\n    ensures self.next_set_request_postconditions(*old(self), sent_packets@),\n```\n\nImplement the function body:", "target_text": "{\nproof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n}", "full_function": "    fn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_set_request_preconditions()\n        ensures  self.next_set_request_postconditions(*old(self), sent_packets@)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_set_request", "function_mode": "exec", "line_start": 1171, "line_end": 1332, "has_loop_invariant": false, "has_proof_block": true, "num_proof_blocks": 4, "has_ghost_vars": true, "body_lines": 159, "complexity_score": 60, "is_method": true, "impl_type": "HostState"}}
{"id": "task_b_set_lib_ext_v_lemma_flatten_sets_union_157", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),\n```\n\nImplement the function body:", "target_text": "{\nassert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}", "full_function": "\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_flatten_sets_union", "function_mode": "proof", "line_start": 43, "line_end": 49, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 4, "complexity_score": 3, "is_method": false, "impl_type": null}}
{"id": "task_b_hashmap_t_new_40", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn new() -> (out: CKeyHashMap)\n    ensures out@ == Map::<AbstractKey, Seq<u8>>::empty(),\n```\n\nImplement the function body:", "target_text": "{\nCKeyHashMap { m: collections::HashMap::new() }\n}", "full_function": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        ensures out@ == Map::<AbstractKey, Seq<u8>>::empty()\n    {\n      CKeyHashMap { m: collections::HashMap::new() }\n    }", "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "new", "function_mode": "exec", "line_start": 34, "line_end": 40, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "CKeyHashMap"}}
{"id": "task_b_delegation_map_v_range_consistent_subset_146", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID)\n    requires self.range_consistent(x, y, dst), x_inner.geq_spec(*x), !y.lt_spec(*y_inner), ensures self.range_consistent(x_inner, y_inner, dst),\n    ensures self.range_consistent(x_inner, y_inner, dst),\n```\n\nImplement the function body:", "target_text": "{\nK::cmp_properties();\n}", "full_function": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "range_consistent_subset", "function_mode": "proof", "line_start": 1368, "line_end": 1378, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<K>"}}
{"id": "task_b_host_impl_v_effect_of_delegation_map_set_93", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n    requires pre.valid(), post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()], ensures AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>,\n    ensures AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>,\n```\n\nImplement the function body:", "target_text": "{\nlo: *lo, hi: *hi\n}", "full_function": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "effect_of_delegation_map_set", "function_mode": "proof", "line_start": 1333, "line_end": 1347, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 1, "complexity_score": 4, "is_method": true, "impl_type": "HostState"}}
{"id": "task_b_set_lib_ext_v_lemma_flatten_set_seq_spec_161", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==> exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)), (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==> flatten_set_seq(sets).contains(x)) decreases sets.len(),\n    decreases sets.len(),\n```\n\nImplement the function body:", "target_text": "{\nif sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}", "full_function": "\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures\n        (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_flatten_set_seq_spec", "function_mode": "proof", "line_start": 111, "line_end": 140, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 22, "complexity_score": 8, "is_method": false, "impl_type": null}}
{"id": "task_b_hashmap_t_len_41", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier::external_body]\npub fn len(&self) -> (l: usize)\n    ensures l as int == self@.len(),\n```\n\nImplement the function body:", "target_text": "{\nself.m.len()\n}", "full_function": "\n    #[verifier::external_body]\n    pub fn len(&self) -> (l: usize)\n    ensures l as int == self@.len()\n    {\n        self.m.len()\n    }", "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "len", "function_mode": "exec", "line_start": 41, "line_end": 47, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "CKeyHashMap"}}
{"id": "task_b_host_impl_t_next_impl_1", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>)\n    requires Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n```\n\nImplement the function body:", "target_text": "{\nself.real_next_impl(netc)\n}", "full_function": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_t.rs", "function_name": "next_impl", "function_mode": "exec", "line_start": 139, "line_end": 146, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 4, "is_method": true, "impl_type": "HostState"}}
{"id": "task_b_cmessage_v_clone_up_to_view_76", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn clone_up_to_view(&self) -> (c: Self)\n    ensures c@ == self@,\n```\n\nImplement the function body:", "target_text": "{\nmatch self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n}", "full_function": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_up_to_view", "function_mode": "exec", "line_start": 246, "line_end": 258, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 9, "complexity_score": 2, "is_method": true, "impl_type": "CSingleMessage"}}
{"id": "task_b_delegation_map_v_new_122", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn new(k: K) -> (s: Self)\n    ensures s.k == Some(k),\n```\n\nImplement the function body:", "target_text": "{\nKeyIterator { k: Some(k) }\n}", "full_function": "    pub fn new(k: K) -> (s: Self)\n        ensures s.k == Some(k)\n    {\n        KeyIterator { k: Some(k) }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 333, "line_end": 337, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_b_io_t_get_time_61", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn get_time(&mut self) -> (time: u64)\n    requires old(self).state() is Receiving ensures (,\n    ensures (,\n```\n\nImplement the function body:", "target_text": "{\n&&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n}", "full_function": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        ensures ({\n            &&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n        }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_time", "function_mode": "exec", "line_start": 282, "line_end": 290, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 4, "complexity_score": 4, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_b_delegation_map_v_new_115", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn new() -> (v: Self)\n    ensures v@ == Seq::<K>::empty(), v.valid(),\n```\n\nImplement the function body:", "target_text": "{\nStrictlyOrderedVec { v: Vec::new() }\n}", "full_function": "\n    fn new() -> (v: Self)\n        ensures v@ == Seq::<K>::empty(),\n                v.valid(),\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 126, "line_end": 132, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_b_net_sht_v_send_packet_seq_55", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>)\n    requires old(netc).ok(), outbound_packet_seq_is_valid(cpackets@), outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (,\n    ensures netc.my_end_point() == old(netc).my_end_point(), (,\n```\n\nImplement the function body:", "target_text": "{\nlet (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n}", "full_function": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet_seq", "function_mode": "exec", "line_start": 353, "line_end": 369, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 10, "complexity_score": 6, "is_method": false, "impl_type": null}}
