{"id": "task_b_seq_lib_v_lemma_seq_add_subrange_172", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n    requires 0 <= i <= j <= k <= s.len(), ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n    ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n```\n\nImplement the function body:", "target_text": "{\nassert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "full_function": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "lemma_seq_add_subrange", "function_mode": "proof", "line_start": 15, "line_end": 22, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 5, "is_method": false, "impl_type": null}}
{"id": "task_b_delegation_map_v_greatest_lower_bound_index_137", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n    requires self.valid(), self@.contains_key(K::zero_spec()), ensures 0 <= index < self.keys@.len(), self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    ensures 0 <= index < self.keys@.len(), self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n```\n\nImplement the function body:", "target_text": "{\nlet mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n}", "full_function": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound_index", "function_mode": "exec", "line_start": 760, "line_end": 804, "has_loop_invariant": true, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 38, "complexity_score": 12, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_b_io_t_send_64", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<()\n    requires !(old(self).state() is Error) ensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send,\n    ensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send,\n```\n\nImplement the function body:", "target_text": "{\ns: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}\n}", "full_function": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "send", "function_mode": "exec", "line_start": 399, "line_end": 407, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 1, "complexity_score": 4, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_b_io_t_get_time_internal_60", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external)]\n#[verifier(external)]\npub fn get_time_internal(&self) -> (time: u64)\n    requires from_trusted_code(),\n```\n\nImplement the function body:", "target_text": "{\n(self.c_pointers.get_time_func)()\n}", "full_function": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        requires\n            from_trusted_code()\n    {\n        (self.c_pointers.get_time_func)()\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_time_internal", "function_mode": "exec", "line_start": 274, "line_end": 281, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_b_seq_is_unique_v_do_vec_u8s_match_24", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n    ensures eq == (e1@ == e2@),\n```\n\nImplement the function body:", "target_text": "{\nif e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n}", "full_function": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "do_vec_u8s_match", "function_mode": "exec", "line_start": 18, "line_end": 48, "has_loop_invariant": true, "has_proof_block": true, "num_proof_blocks": 1, "has_ghost_vars": false, "body_lines": 27, "complexity_score": 13, "is_method": false, "impl_type": null}}
{"id": "task_b_single_delivery_state_v_abstractify_distributes_over_skip_7", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires 0 <= i <= cm.len(), ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i,\n    ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i,\n    decreases i,\n```\n\nImplement the function body:", "target_text": "{\nif 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n}", "full_function": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "abstractify_distributes_over_skip", "function_mode": "proof", "line_start": 138, "line_end": 149, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 5, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_b_single_delivery_state_v_truncate_8", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn truncate(&mut self, seqno_acked: u64, Ghost(dst)\n    requires old(self).valid(dst), old(self).num_packets_acked <= seqno_acked, ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\n    ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\n```\n\nImplement the function body:", "target_text": "{\nlet mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n}", "full_function": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "truncate", "function_mode": "exec", "line_start": 150, "line_end": 194, "has_loop_invariant": true, "has_proof_block": true, "num_proof_blocks": 1, "has_ghost_vars": false, "body_lines": 35, "complexity_score": 16, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_b_delegation_map_v_len_116", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn len(&self) -> (len: usize )\n    ensures len == self@.len(),\n```\n\nImplement the function body:", "target_text": "{\nself.v.len()\n}", "full_function": "\n    fn len(&self) -> (len: usize )\n        ensures len == self@.len()\n    {\n        self.v.len()\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "len", "function_mode": "exec", "line_start": 133, "line_end": 138, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_b_single_delivery_model_v_same_view_same_marshalable_23", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\n    requires x@ == y@, ensures x.is_marshalable() == y.is_marshalable(),\n    ensures x.is_marshalable() == y.is_marshalable(),\n```\n\nImplement the function body:", "target_text": "{\nCSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "full_function": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "same_view_same_marshalable", "function_mode": "proof", "line_start": 26, "line_end": 37, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 5, "complexity_score": 5, "is_method": false, "impl_type": null}}
{"id": "task_b_delegation_map_v_delegate_for_key_range_is_host_impl_150", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n    requires self.valid(), ensures b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange,\n    ensures b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange,\n```\n\nImplement the function body:", "target_text": "{\nlo: *lo, hi: *hi\n}", "full_function": "\n\n    pub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n        requires\n            self.valid(),\n        ensures\n            b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange { lo: *lo, hi: *hi }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "delegate_for_key_range_is_host_impl", "function_mode": "exec", "line_start": 1698, "line_end": 1704, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 1, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<AbstractKey>"}}
{"id": "task_b_seq_is_unique_v_endpoints_contain_27", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n    ensures present == abstractify_end_points(*endpoints).contains(endpoint@),\n```\n\nImplement the function body:", "target_text": "{\nlet mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n}", "full_function": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "endpoints_contain", "function_mode": "exec", "line_start": 104, "line_end": 123, "has_loop_invariant": true, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 17, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_b_marshal_v__is_marshalable_36", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nexecfn _is_marshalable(&self) -> bool\n```\n\nImplement the function body:", "target_text": "{\nlet mut res = true;\n    let mut i = 0;\n    let mut total_len = self.len().serialized_size();\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while res && i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        res ==> total_len as int == (self@.len() as usize).ghost_serialize().len() +\n                 self@.subrange(0, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n        res ==> (forall |x: T| self@.subrange(0, i as int).contains(x) ==> #[trigger] x.is_marshalable()),\n        res ==> total_len as int <= usize::MAX,\n        !res ==> !self.is_marshalable(),\n      decreases\n        self.len() - i + if res { 1int } else { 0int }\n    {\n      assert(res);\n      res = res && self[i]._is_marshalable() && (usize::MAX - total_len >= self[i].serialized_size());\n      if res {\n        let old_total_len = total_len;\n        total_len = total_len + self[i].serialized_size();\n        i = i + 1;\n        proof {\n          assert forall |x: T| #[trigger] self@.subrange(0, i as int).contains(x) implies x.is_marshalable() by {\n            if (exists |j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x) {\n              let j = choose|j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x;\n              assert(self@.subrange(0, i as int - 1)[j] == x); // OBSERVE\n            }\n          };\n          let sl = |x: T| x.ghost_serialize().len() as int;\n          assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n          let s = self@.subrange(0 as int, i as int);\n          seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n          assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n        }\n      } else {\n        proof {\n          if usize::MAX < total_len + self@[i as int].ghost_serialize().len() {\n            assert(\n              ((self@.len() as usize).ghost_serialize().len() +\n               self@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()))\n                >=\n              (total_len + self@[i as int].ghost_serialize().len())\n            ) by {\n              let f = |x: T| x.ghost_serialize();\n              let sl = |x: T| x.ghost_serialize().len() as int;\n              let s = self@.subrange(0 as int, i as int + 1);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n              seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n              assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i as int));\n              seq_lib_v::lemma_seq_fold_left_append_len_int_le(self@, i as int + 1, 0, f);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + f(x).len()));\n            };\n          } else {\n            assert(!self@[i as int].is_marshalable());\n          }\n        }\n      }\n    }\n\n    res\n}", "full_function": "\n  exec fn _is_marshalable(&self) -> bool {\n    let mut res = true;\n    let mut i = 0;\n    let mut total_len = self.len().serialized_size();\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while res && i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        res ==> total_len as int == (self@.len() as usize).ghost_serialize().len() +\n                 self@.subrange(0, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n        res ==> (forall |x: T| self@.subrange(0, i as int).contains(x) ==> #[trigger] x.is_marshalable()),\n        res ==> total_len as int <= usize::MAX,\n        !res ==> !self.is_marshalable(),\n      decreases\n        self.len() - i + if res { 1int } else { 0int }\n    {\n      assert(res);\n      res = res && self[i]._is_marshalable() && (usize::MAX - total_len >= self[i].serialized_size());\n      if res {\n        let old_total_len = total_len;\n        total_len = total_len + self[i].serialized_size();\n        i = i + 1;\n        proof {\n          assert forall |x: T| #[trigger] self@.subrange(0, i as int).contains(x) implies x.is_marshalable() by {\n            if (exists |j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x) {\n              let j = choose|j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x;\n              assert(self@.subrange(0, i as int - 1)[j] == x); // OBSERVE\n            }\n          };\n          let sl = |x: T| x.ghost_serialize().len() as int;\n          assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n          let s = self@.subrange(0 as int, i as int);\n          seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n          assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n        }\n      } else {\n        proof {\n          if usize::MAX < total_len + self@[i as int].ghost_serialize().len() {\n            assert(\n              ((self@.len() as usize).ghost_serialize().len() +\n               self@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()))\n                >=\n              (total_len + self@[i as int].ghost_serialize().len())\n            ) by {\n              let f = |x: T| x.ghost_serialize();\n              let sl = |x: T| x.ghost_serialize().len() as int;\n              let s = self@.subrange(0 as int, i as int + 1);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n              seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n              assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i as int));\n              seq_lib_v::lemma_seq_fold_left_append_len_int_le(self@, i as int + 1, 0, f);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + f(x).len()));\n            };\n          } else {\n            assert(!self@[i as int].is_marshalable());\n          }\n        }\n      }\n    }\n\n    res\n  }", "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "_is_marshalable", "function_mode": "exec", "line_start": 619, "line_end": 685, "has_loop_invariant": true, "has_proof_block": true, "num_proof_blocks": 3, "has_ghost_vars": false, "body_lines": 66, "complexity_score": 29, "is_method": false, "impl_type": null}}
{"id": "task_b_io_t_receive_62", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n    requires old(self).state() is Receiving ensures self.my_end_point() == old(self).my_end_point(), match result,\n    ensures self.my_end_point() == old(self).my_end_point(), match result,\n```\n\nImplement the function body:", "target_text": "{\nNetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n}", "full_function": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "receive", "function_mode": "exec", "line_start": 335, "line_end": 361, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 20, "complexity_score": 4, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_b_endpoint_hashmap_t_get_67", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n    ensures value == match Self::get_spec(self@, key@),\n```\n\nImplement the function body:", "target_text": "{\nSome(v) => Some(&v), None => None\n}", "full_function": "\n    #[verifier(external_body)]\n    pub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n    ensures\n        value == match Self::get_spec(self@, key@) { Some(v) => Some(&v), None => None }", "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "get", "function_mode": "exec", "line_start": 57, "line_end": 61, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 1, "complexity_score": 2, "is_method": true, "impl_type": "HashMap<V>"}}
{"id": "task_b_cmessage_v_view_equal_spec_75", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn view_equal_spec()\n    ensures forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@,\n```\n\nImplement the function body:", "target_text": "{\nassert forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n}", "full_function": "\n  pub proof fn view_equal_spec()\n    ensures forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@\n  {\n    assert forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "view_equal_spec", "function_mode": "proof", "line_start": 225, "line_end": 245, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 18, "complexity_score": 7, "is_method": true, "impl_type": "CSingleMessage"}}
{"id": "task_b_single_delivery_state_v_lemma_seqno_in_un_acked_list_6", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n    requires self.valid(dst), 0 <= k < self.un_acked@.len(), ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k,\n    ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k,\n    decreases k,\n```\n\nImplement the function body:", "target_text": "{\nif k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n}", "full_function": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lemma_seqno_in_un_acked_list", "function_mode": "proof", "line_start": 124, "line_end": 137, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 5, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_b_seq_is_unique_v_clone_end_point_29", "task": "spec_to_code", "input_text": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n    ensures cloned_ep@ == ep@,\n```\n\nImplement the function body:", "target_text": "{\nEndPoint{id: clone_vec_u8(&ep.id)}\n}", "full_function": "\n    pub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n        ensures\n            cloned_ep@ == ep@\n    {\n        EndPoint{id: clone_vec_u8(&ep.id)}\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_end_point", "function_mode": "exec", "line_start": 137, "line_end": 143, "has_loop_invariant": false, "has_proof_block": false, "num_proof_blocks": 0, "has_ghost_vars": false, "body_lines": 3, "complexity_score": 2, "is_method": false, "impl_type": null}}
