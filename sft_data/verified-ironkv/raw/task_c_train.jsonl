{"id": "task_c_set_lib_ext_v_lemma_flatten_sets_insert_156_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    \n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s)\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}", "broken_code": "\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    ", "fixed_code": "\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s)\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 37, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_flatten_sets_insert", "mutation_type": "remove_ensures", "fix_description": "Add ensures: flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s)", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_lemma_seqno_in_un_acked_list_6_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "broken_code": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "fixed_code": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 124, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lemma_seqno_in_un_acked_list", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(dst), 0 <= k < self.un_acked@.len(), ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k", "synthetic": true}}
{"id": "task_c_cmessage_v_clone_value_72_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n  pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  \n```\n\nProvide the fixed code:", "target_text": "  pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  ensures\n      match value {\n          Some(vec) => {\n              &&& out is Some\n              &&& out.unwrap()@ == vec@\n          }\n          None => {\n              &&& out is None\n          }\n      }", "broken_code": "  pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  ", "fixed_code": "  pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  ensures\n      match value {\n          Some(vec) => {\n              &&& out is Some\n              &&& out.unwrap()@ == vec@\n          }\n          None => {\n              &&& out is None\n          }\n      }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 107, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_value", "mutation_type": "remove_ensures", "fix_description": "Add ensures: match value", "synthetic": true}}
{"id": "task_c_marshal_v_serialized_size_37_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n  exec fn serialized_size(&self) -> (res: usize)\n    // req, ens from trait\n  {\n    let mut res = self.len().serialized_size();\n    let mut i = 0;\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while i < self.len()\n      \n        (forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable()),\n        (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, self@.len() as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) <= usize::MAX,\n        res == (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n      decreases\n        self.len() - i\n    {\n      proof {\n        let f = |x: T| x.ghost_serialize();\n        assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n        seq_lib_v::lemma_seq_fold_left_append_len_int_le::<T, u8>(self@, i + 1 as int, 0, f);\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        let accl = |acc: int, x: T| acc + x.ghost_serialize().len() as int;\n        assert(accl =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i + 1 as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1 as int) =~= self@.subrange(0 as int, i as int));\n        assert(self@.subrange(0 as int, self@.len() as int) =~= self@);\n      }\n      let old_res: Ghost<usize> = Ghost(res);\n      res = res + self[i].serialized_size();\n      i = i + 1;\n      proof {\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n      }\n    }\n\n    proof {\n      let f = |x: T| x.ghost_serialize();\n      seq_lib_v::lemma_seq_fold_left_append_len_int::<T, u8>(self@, Seq::<u8>::empty(), f);\n      assert((|acc: Seq<u8>, x: T| acc + f(x)) =~= (|acc: Seq<u8>, x: T| acc + x.ghost_serialize()));\n      assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n      assert(self@.subrange(0 as int, i as int) =~= self@);\n    }\n\n    res\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  exec fn serialized_size(&self) -> (res: usize)\n    // req, ens from trait\n  {\n    let mut res = self.len().serialized_size();\n    let mut i = 0;\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        (forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable()),\n        (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, self@.len() as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) <= usize::MAX,\n        res == (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n      decreases\n        self.len() - i\n    {\n      proof {\n        let f = |x: T| x.ghost_serialize();\n        assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n        seq_lib_v::lemma_seq_fold_left_append_len_int_le::<T, u8>(self@, i + 1 as int, 0, f);\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        let accl = |acc: int, x: T| acc + x.ghost_serialize().len() as int;\n        assert(accl =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i + 1 as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1 as int) =~= self@.subrange(0 as int, i as int));\n        assert(self@.subrange(0 as int, self@.len() as int) =~= self@);\n      }\n      let old_res: Ghost<usize> = Ghost(res);\n      res = res + self[i].serialized_size();\n      i = i + 1;\n      proof {\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n      }\n    }\n\n    proof {\n      let f = |x: T| x.ghost_serialize();\n      seq_lib_v::lemma_seq_fold_left_append_len_int::<T, u8>(self@, Seq::<u8>::empty(), f);\n      assert((|acc: Seq<u8>, x: T| acc + f(x)) =~= (|acc: Seq<u8>, x: T| acc + x.ghost_serialize()));\n      assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n      assert(self@.subrange(0 as int, i as int) =~= self@);\n    }\n\n    res\n  }", "broken_code": "\n  exec fn serialized_size(&self) -> (res: usize)\n    // req, ens from trait\n  {\n    let mut res = self.len().serialized_size();\n    let mut i = 0;\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while i < self.len()\n      \n        (forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable()),\n        (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, self@.len() as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) <= usize::MAX,\n        res == (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n      decreases\n        self.len() - i\n    {\n      proof {\n        let f = |x: T| x.ghost_serialize();\n        assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n        seq_lib_v::lemma_seq_fold_left_append_len_int_le::<T, u8>(self@, i + 1 as int, 0, f);\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        let accl = |acc: int, x: T| acc + x.ghost_serialize().len() as int;\n        assert(accl =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i + 1 as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1 as int) =~= self@.subrange(0 as int, i as int));\n        assert(self@.subrange(0 as int, self@.len() as int) =~= self@);\n      }\n      let old_res: Ghost<usize> = Ghost(res);\n      res = res + self[i].serialized_size();\n      i = i + 1;\n      proof {\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n      }\n    }\n\n    proof {\n      let f = |x: T| x.ghost_serialize();\n      seq_lib_v::lemma_seq_fold_left_append_len_int::<T, u8>(self@, Seq::<u8>::empty(), f);\n      assert((|acc: Seq<u8>, x: T| acc + f(x)) =~= (|acc: Seq<u8>, x: T| acc + x.ghost_serialize()));\n      assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n      assert(self@.subrange(0 as int, i as int) =~= self@);\n    }\n\n    res\n  }", "fixed_code": "\n  exec fn serialized_size(&self) -> (res: usize)\n    // req, ens from trait\n  {\n    let mut res = self.len().serialized_size();\n    let mut i = 0;\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        (forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable()),\n        (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, self@.len() as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) <= usize::MAX,\n        res == (self@.len() as usize).ghost_serialize().len() +\n               self@.subrange(0 as int, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n      decreases\n        self.len() - i\n    {\n      proof {\n        let f = |x: T| x.ghost_serialize();\n        assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n        seq_lib_v::lemma_seq_fold_left_append_len_int_le::<T, u8>(self@, i + 1 as int, 0, f);\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        let accl = |acc: int, x: T| acc + x.ghost_serialize().len() as int;\n        assert(accl =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i + 1 as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1 as int) =~= self@.subrange(0 as int, i as int));\n        assert(self@.subrange(0 as int, self@.len() as int) =~= self@);\n      }\n      let old_res: Ghost<usize> = Ghost(res);\n      res = res + self[i].serialized_size();\n      i = i + 1;\n      proof {\n        let sl = |x: T| x.ghost_serialize().len() as int;\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n        let s = self@.subrange(0 as int, i as int);\n        seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n        assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n      }\n    }\n\n    proof {\n      let f = |x: T| x.ghost_serialize();\n      seq_lib_v::lemma_seq_fold_left_append_len_int::<T, u8>(self@, Seq::<u8>::empty(), f);\n      assert((|acc: Seq<u8>, x: T| acc + f(x)) =~= (|acc: Seq<u8>, x: T| acc + x.ghost_serialize()));\n      assert((|acc: int, x: T| acc + f(x).len()) =~= (|acc: int, x: T| acc + x.ghost_serialize().len()));\n      assert(self@.subrange(0 as int, i as int) =~= self@);\n    }\n\n    res\n  }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/marshal_v.rs", "line_number": 691, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "serialized_size", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= i <= self.len()", "synthetic": true}}
{"id": "task_c_host_protocol_t_workaround_dermarshal_not_invertible_3_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn workaround_dermarshal_not_invertible()\n\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn workaround_dermarshal_not_invertible()\nensures okay_to_ignore_packets()\n{\n    reveal(okay_to_ignore_packets);\n}", "broken_code": "\npub proof fn workaround_dermarshal_not_invertible()\n", "fixed_code": "\npub proof fn workaround_dermarshal_not_invertible()\nensures okay_to_ignore_packets()\n{\n    reveal(okay_to_ignore_packets);\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_protocol_t.rs", "line_number": 117, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_protocol_t.rs", "function_name": "workaround_dermarshal_not_invertible", "mutation_type": "remove_ensures", "fix_description": "Add ensures: okay_to_ignore_packets()", "synthetic": true}}
{"id": "task_c_net_sht_v_send_packet_54_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "broken_code": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "fixed_code": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 274, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet", "mutation_type": "remove_requires", "fix_description": "Add requires: old(netc).ok(), outbound_packet_is_valid(cpacket), cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc ensures netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_marshal_ironsht_specific_v_view_equal_spec_154_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n        pub proof fn view_equal_spec()\n            \n```\n\nProvide the fixed code:", "target_text": "        pub proof fn view_equal_spec()\n            ensures forall |x: &SHTKey, y: &SHTKey| #[trigger] x.view_equal(y) <==> x == y\n        {\n        }", "broken_code": "        pub proof fn view_equal_spec()\n            ", "fixed_code": "        pub proof fn view_equal_spec()\n            ensures forall |x: &SHTKey, y: &SHTKey| #[trigger] x.view_equal(y) <==> x == y\n        {\n        }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/marshal_ironsht_specific_v.rs", "line_number": 39, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/marshal_ironsht_specific_v.rs", "function_name": "view_equal_spec", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: &SHTKey, y: &SHTKey| #[trigger] x.view_equal(y) <==> x == y", "synthetic": true}}
{"id": "task_c_delegation_map_v_choose_gap_violator_130_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn choose_gap_violator(self, lo:KeyIterator<K>, hi:KeyIterator<K>) -> (r: KeyIterator<K>)\n        requires\n            !self.gap(lo, hi),\n        ensures\n            lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get()),\n    {\n        choose |r| #![auto] lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get_spec())\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn choose_gap_violator(self, lo:KeyIterator<K>, hi:KeyIterator<K>) -> (r: KeyIterator<K>)\n        requires\n            !self.gap(lo, hi),\n        ensures\n            lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get()),\n    {\n        choose |r| #![auto] lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get_spec())\n    }", "broken_code": "\n    proof fn choose_gap_violator(self, lo:KeyIterator<K>, hi:KeyIterator<K>) -> (r: KeyIterator<K>)\n        requires\n            !self.gap(lo, hi),\n        ensures\n            lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get()),\n    {\n        choose |r| #![auto] lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get_spec())\n    }", "fixed_code": "\n    proof fn choose_gap_violator(self, lo:KeyIterator<K>, hi:KeyIterator<K>) -> (r: KeyIterator<K>)\n        requires\n            !self.gap(lo, hi),\n        ensures\n            lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get()),\n    {\n        choose |r| #![auto] lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get_spec())\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 506, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "choose_gap_violator", "mutation_type": "remove_requires", "fix_description": "Add requires: !self.gap(lo, hi), ensures lo.lt_spec(r) && r.lt_spec(hi) && self@.contains_key(*r.get())", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_do_end_points_match_25_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn do_end_points_match(e1: &EndPoint, e2: &EndPoint) -> (eq: bool)\n         &e2.id)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn do_end_points_match(e1: &EndPoint, e2: &EndPoint) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        do_vec_u8s_match(&e1.id, &e2.id)\n    }", "broken_code": "\n    pub fn do_end_points_match(e1: &EndPoint, e2: &EndPoint) -> (eq: bool)\n         &e2.id)\n    }", "fixed_code": "\n    pub fn do_end_points_match(e1: &EndPoint, e2: &EndPoint) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        do_vec_u8s_match(&e1.id, &e2.id)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 49, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "do_end_points_match", "mutation_type": "remove_ensures", "fix_description": "Add ensures: eq == (e1@ == e2@)", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_clone_end_point_29_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n        \n```\n\nProvide the fixed code:", "target_text": "\n    pub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n        ensures\n            cloned_ep@ == ep@\n    {\n        EndPoint{id: clone_vec_u8(&ep.id)}\n    }", "broken_code": "\n    pub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n        ", "fixed_code": "\n    pub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n        ensures\n            cloned_ep@ == ep@\n    {\n        EndPoint{id: clone_vec_u8(&ep.id)}\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 137, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_end_point", "mutation_type": "remove_ensures", "fix_description": "Add ensures: cloned_ep@ == ep@", "synthetic": true}}
{"id": "task_c_host_impl_v_effect_of_delegation_map_set_93_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n        hi: *hi }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }", "broken_code": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n        hi: *hi }", "fixed_code": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1333, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "effect_of_delegation_map_set", "mutation_type": "remove_ensures", "fix_description": "Add ensures: AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>", "synthetic": true}}
{"id": "task_c_host_impl_t_next_impl_1_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n         *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "broken_code": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n         *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "fixed_code": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_t.rs", "line_number": 139, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_t.rs", "function_name": "next_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_delegation_map_v_erase_120_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }", "broken_code": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }", "fixed_code": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 197, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "erase", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), start <= end <= old(self)@.len(), ensures self.valid(), self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int), // TODO: We might want to strengthen this further to say that the two sets on the RHS // are disjoint old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set()", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_retransmit_un_acked_packets_for_dst_17_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "broken_code": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "fixed_code": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 101, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "retransmit_un_acked_packets_for_dst", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), src.abstractable(), outbound_packet_seq_is_valid(old(packets)@), outbound_packet_seq_has_correct_srcs(old(packets)@, src@), self.send_state@.contains_key(dst@), Self::packets_are_valid_messages(old(packets)@), ensures packets@.map_values(|p: CPacket| p@).to_set() == old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, src@), Self::packets_are_valid_messages(packets@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_insert_121_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            \n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "broken_code": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            \n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "fixed_code": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 284, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "insert", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= index <= self@.len()", "synthetic": true}}
{"id": "task_c_delegation_map_v_range_consistent_subset_146_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        \n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "broken_code": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        \n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "fixed_code": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1368, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "range_consistent_subset", "mutation_type": "remove_requires", "fix_description": "Add requires: self.range_consistent(x, y, dst), x_inner.geq_spec(*x), !y.lt_spec(*y_inner), ensures self.range_consistent(x_inner, y_inner, dst)", "synthetic": true}}
{"id": "task_c_endpoint_hashmap_t_put_68_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn put(&mut self, key: &EndPoint, value: V)\n     key@, value),\n    {\n        self.insert(key, value);\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn put(&mut self, key: &EndPoint, value: V)\n    ensures\n        Self::put_spec(old(self)@, self@, key@, value),\n    {\n        self.insert(key, value);\n    }", "broken_code": "    pub fn put(&mut self, key: &EndPoint, value: V)\n     key@, value),\n    {\n        self.insert(key, value);\n    }", "fixed_code": "    pub fn put(&mut self, key: &EndPoint, value: V)\n    ensures\n        Self::put_spec(old(self)@, self@, key@, value),\n    {\n        self.insert(key, value);\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/endpoint_hashmap_t.rs", "line_number": 84, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "put", "mutation_type": "remove_ensures", "fix_description": "Add ensures: Self::put_spec(old(self)@, self@, key@, value)", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_receive_message_97_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn host_model_next_receive_message(&mut self) -> (sent_packets: Vec<CPacket>)\n         ..} =>\n                              match m {\n                                  CMessage::GetRequest{..} => old_self.next_get_request_preconditions(),\n                                  CMessage::SetRequest{..} => old_self.next_set_request_preconditions(),\n                                  CMessage::Delegate{..} => old_self.next_delegate_preconditions(),\n                                  CMessage::Shard{..} => old_self.next_shard_preconditions(),\n                                  _ => true,\n                              }\n                          _ => false,\n                      }\n                },\n                None => false,\n            }\n        }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_receive_message(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires ({\n            let old_self = *old(self);\n            match old_self.received_packet {\n                Some(cpacket) => {\n                    &&& old(self).sd.valid()\n                    &&& old(self).host_state_common_preconditions()\n                    &&& match cpacket.msg {\n                          CSingleMessage::Message{m: m, ..} =>\n                              match m {\n                                  CMessage::GetRequest{..} => old_self.next_get_request_preconditions(),\n                                  CMessage::SetRequest{..} => old_self.next_set_request_preconditions(),\n                                  CMessage::Delegate{..} => old_self.next_delegate_preconditions(),\n                                  CMessage::Shard{..} => old_self.next_shard_preconditions(),\n                                  _ => true,\n                              }\n                          _ => false,\n                      }\n                },\n                None => false,\n            }\n        }", "broken_code": "    fn host_model_next_receive_message(&mut self) -> (sent_packets: Vec<CPacket>)\n         ..} =>\n                              match m {\n                                  CMessage::GetRequest{..} => old_self.next_get_request_preconditions(),\n                                  CMessage::SetRequest{..} => old_self.next_set_request_preconditions(),\n                                  CMessage::Delegate{..} => old_self.next_delegate_preconditions(),\n                                  CMessage::Shard{..} => old_self.next_shard_preconditions(),\n                                  _ => true,\n                              }\n                          _ => false,\n                      }\n                },\n                None => false,\n            }\n        }", "fixed_code": "    fn host_model_next_receive_message(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires ({\n            let old_self = *old(self);\n            match old_self.received_packet {\n                Some(cpacket) => {\n                    &&& old(self).sd.valid()\n                    &&& old(self).host_state_common_preconditions()\n                    &&& match cpacket.msg {\n                          CSingleMessage::Message{m: m, ..} =>\n                              match m {\n                                  CMessage::GetRequest{..} => old_self.next_get_request_preconditions(),\n                                  CMessage::SetRequest{..} => old_self.next_set_request_preconditions(),\n                                  CMessage::Delegate{..} => old_self.next_delegate_preconditions(),\n                                  CMessage::Shard{..} => old_self.next_shard_preconditions(),\n                                  _ => true,\n                              }\n                          _ => false,\n                      }\n                },\n                None => false,\n            }\n        }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1558, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_receive_message", "mutation_type": "remove_requires", "fix_description": "Add requires: (", "synthetic": true}}
{"id": "task_c_cmessage_v_is_value_valid_80_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\npub fn is_value_valid(val: &Vec<u8>) -> (b: bool)\n    \n```\n\nProvide the fixed code:", "target_text": "pub fn is_value_valid(val: &Vec<u8>) -> (b: bool)\n    ensures b == valid_value(val@)\n{\n    val.len() < 1024\n}", "broken_code": "pub fn is_value_valid(val: &Vec<u8>) -> (b: bool)\n    ", "fixed_code": "pub fn is_value_valid(val: &Vec<u8>) -> (b: bool)\n    ensures b == valid_value(val@)\n{\n    val.len() < 1024\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 59, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_value_valid", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == valid_value(val@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_new_140_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "broken_code": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "fixed_code": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1052, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "mutation_type": "remove_requires", "fix_description": "Add requires: k_zero == K::zero_spec(), id_zero@.valid_physical_address(), ensures s.valid(), s@ == Map::total(|k: K| id_zero@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_valid_implies_complete_141_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        \n```\n\nProvide the fixed code:", "target_text": "\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ensures  self@.dom().is_full()\n    {\n    }", "broken_code": "\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ", "fixed_code": "\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ensures  self@.dom().is_full()\n    {\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1067, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "valid_implies_complete", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@.dom().is_full()", "synthetic": true}}
{"id": "task_c_delegation_map_v_set_136_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "broken_code": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "fixed_code": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 689, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "set", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), ensures self.valid(), self@ == old(self)@.insert(k, v), forall |lo, hi| self.gap(lo, hi) <==> old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi))", "synthetic": true}}
{"id": "task_c_net_sht_v_receive_with_demarshal_53_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\npub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\n net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}\n```\n\nProvide the fixed code:", "target_text": "pub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\nensures\n    ({let (rr, net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}", "broken_code": "pub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\n net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}", "fixed_code": "pub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\nensures\n    ({let (rr, net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 169, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "receive_with_demarshal", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (", "synthetic": true}}
{"id": "task_c_io_t_get_time_61_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        ensures ({\n            &&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n        }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        ensures ({\n            &&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n        }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/io_t.rs", "line_number": 282, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_time", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).state() is Receiving ensures (", "synthetic": true}}
{"id": "task_c_hashmap_t_clone_up_to_view_49_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn clone_up_to_view(&self) -> (out: Self)\n    \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn clone_up_to_view(&self) -> (out: Self)\n    ensures\n        out@ == self@\n    {\n        Self::from_vec(self.to_vec())\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn clone_up_to_view(&self) -> (out: Self)\n    ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn clone_up_to_view(&self) -> (out: Self)\n    ensures\n        out@ == self@\n    {\n        Self::from_vec(self.to_vec())\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 151, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "clone_up_to_view", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out@ == self@", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_internal_142_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n         glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }\n```\n\nProvide the fixed code:", "target_text": "    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n        ensures ({\n            let (id, glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }", "broken_code": "    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n         glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }", "fixed_code": "    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n        ensures ({\n            let (id, glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1076, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get_internal", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (", "synthetic": true}}
{"id": "task_c_delegation_map_v_all_keys_agree_148_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }", "broken_code": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }", "fixed_code": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1388, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "all_keys_agree", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), 0 <= lo <= hi < self.lows.keys@.len(), forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@, ensures self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id), decreases hi - lo", "synthetic": true}}
{"id": "task_c_host_impl_v_deliver_outbound_packets_86_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        \n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }\n```\n\nProvide the fixed code:", "target_text": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "broken_code": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        \n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "fixed_code": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 519, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_outbound_packets", "mutation_type": "remove_ensures", "fix_description": "Add ensures: netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_delegation_map_v_keys_in_index_range_agree_134_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn keys_in_index_range_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        \n            !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@))),\n    {\n        let (agree, almost) = self.values_agree(lo, hi, v);\n        proof {\n            if agree {\n            } else {\n                assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@);\n                let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@);\n                assert(self.vals@.index(i)@ != v@);\n                assert(self@[self.keys@[i]]@ == self.vals@.index(i)@);\n                if almost {\n                } else {\n                    assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@));\n                    if self.vals@[hi as int]@ == v@ {\n                    } else {\n                        let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@;\n                        assert(self@[self.keys@[j]]@ != v@);\n                    }\n                }\n            }\n        }\n        (agree, almost)\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn keys_in_index_range_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self@[self.keys@[i]]@ == v@,\n            !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@))),\n    {\n        let (agree, almost) = self.values_agree(lo, hi, v);\n        proof {\n            if agree {\n            } else {\n                assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@);\n                let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@);\n                assert(self.vals@.index(i)@ != v@);\n                assert(self@[self.keys@[i]]@ == self.vals@.index(i)@);\n                if almost {\n                } else {\n                    assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@));\n                    if self.vals@[hi as int]@ == v@ {\n                    } else {\n                        let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@;\n                        assert(self@[self.keys@[j]]@ != v@);\n                    }\n                }\n            }\n        }\n        (agree, almost)\n    }", "broken_code": "    fn keys_in_index_range_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        \n            !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@))),\n    {\n        let (agree, almost) = self.values_agree(lo, hi, v);\n        proof {\n            if agree {\n            } else {\n                assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@);\n                let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@);\n                assert(self.vals@.index(i)@ != v@);\n                assert(self@[self.keys@[i]]@ == self.vals@.index(i)@);\n                if almost {\n                } else {\n                    assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@));\n                    if self.vals@[hi as int]@ == v@ {\n                    } else {\n                        let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@;\n                        assert(self@[self.keys@[j]]@ != v@);\n                    }\n                }\n            }\n        }\n        (agree, almost)\n    }", "fixed_code": "    fn keys_in_index_range_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self@[self.keys@[i]]@ == v@,\n            !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@))),\n    {\n        let (agree, almost) = self.values_agree(lo, hi, v);\n        proof {\n            if agree {\n            } else {\n                assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@);\n                let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@);\n                assert(self.vals@.index(i)@ != v@);\n                assert(self@[self.keys@[i]]@ == self.vals@.index(i)@);\n                if almost {\n                } else {\n                    assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@));\n                    if self.vals@[hi as int]@ == v@ {\n                    } else {\n                        let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@;\n                        assert(self@[self.keys@[j]]@ != v@);\n                    }\n                }\n            }\n        }\n        (agree, almost)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 604, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "keys_in_index_range_agree", "mutation_type": "remove_ensures", "fix_description": "Add ensures: ret.0 == forall |i| #![auto] lo <= i <= hi ==> self@[self.keys@[i]]@ == v@, !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@)))", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_flatten_sets_singleton_auto_170_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub proof fn flatten_sets_singleton_auto<A>()\n\n{\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn flatten_sets_singleton_auto<A>()\nensures\n    forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x,\n{\n}", "broken_code": "\n\npub proof fn flatten_sets_singleton_auto<A>()\n\n{\n}", "fixed_code": "\n\npub proof fn flatten_sets_singleton_auto<A>()\nensures\n    forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x,\n{\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 303, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "flatten_sets_singleton_auto", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x", "synthetic": true}}
{"id": "task_c_delegation_map_v_set_118_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "broken_code": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "fixed_code": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 147, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "set", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), self@ == old(self)@.update(i as int, k)", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_delegate_95_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n         sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "broken_code": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n         sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "fixed_code": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1377, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_delegate", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.next_delegate_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_cack_state_swap_12_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n     self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "broken_code": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n     self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "fixed_code": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 283, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "cack_state_swap", "mutation_type": "remove_ensures", "fix_description": "Add ensures: HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default)", "synthetic": true}}
{"id": "task_c_marshal_v_serialize_38_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(\n        data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())\n      );\n    }\n\n    while i < self.len()\n      \n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize()),\n        forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable(),\n        data@.len() >= old(data)@.len(),\n      decreases\n        self.len() - i\n    {\n      self[i].serialize(data);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert(data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())) by {\n          let s = self@;\n          let emp = Seq::<u8>::empty();\n          let accf = |acc: Seq<u8>, x: T| acc + x.ghost_serialize();\n          let f = |x: T| x.ghost_serialize();\n          let t = s.subrange(0, i as int);\n\n          assert(accf =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n          assert(t.subrange(0, t.len() - 1) =~= s.subrange(0, i - 1));\n          seq_lib_v::lemma_seq_fold_left_append_right(t, emp, f);\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              s.subrange(0, (i - 1) as int).fold_left(emp, accf) +\n              s.index((i - 1) as int).ghost_serialize()\n          );\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              t.fold_left(emp, accf)\n          );\n        }\n      }\n    }\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(\n        data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())\n      );\n    }\n\n    while i < self.len()\n      invariant\n        i <= self.len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize()),\n        forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable(),\n        data@.len() >= old(data)@.len(),\n      decreases\n        self.len() - i\n    {\n      self[i].serialize(data);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert(data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())) by {\n          let s = self@;\n          let emp = Seq::<u8>::empty();\n          let accf = |acc: Seq<u8>, x: T| acc + x.ghost_serialize();\n          let f = |x: T| x.ghost_serialize();\n          let t = s.subrange(0, i as int);\n\n          assert(accf =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n          assert(t.subrange(0, t.len() - 1) =~= s.subrange(0, i - 1));\n          seq_lib_v::lemma_seq_fold_left_append_right(t, emp, f);\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              s.subrange(0, (i - 1) as int).fold_left(emp, accf) +\n              s.index((i - 1) as int).ghost_serialize()\n          );\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              t.fold_left(emp, accf)\n          );\n        }\n      }\n    }\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n  }", "broken_code": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(\n        data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())\n      );\n    }\n\n    while i < self.len()\n      \n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize()),\n        forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable(),\n        data@.len() >= old(data)@.len(),\n      decreases\n        self.len() - i\n    {\n      self[i].serialize(data);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert(data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())) by {\n          let s = self@;\n          let emp = Seq::<u8>::empty();\n          let accf = |acc: Seq<u8>, x: T| acc + x.ghost_serialize();\n          let f = |x: T| x.ghost_serialize();\n          let t = s.subrange(0, i as int);\n\n          assert(accf =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n          assert(t.subrange(0, t.len() - 1) =~= s.subrange(0, i - 1));\n          seq_lib_v::lemma_seq_fold_left_append_right(t, emp, f);\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              s.subrange(0, (i - 1) as int).fold_left(emp, accf) +\n              s.index((i - 1) as int).ghost_serialize()\n          );\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              t.fold_left(emp, accf)\n          );\n        }\n      }\n    }\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n  }", "fixed_code": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(\n        data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())\n      );\n    }\n\n    while i < self.len()\n      invariant\n        i <= self.len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize()),\n        forall |x: T| self@.contains(x) ==> #[trigger] x.is_marshalable(),\n        data@.len() >= old(data)@.len(),\n      decreases\n        self.len() - i\n    {\n      self[i].serialize(data);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert(data@.subrange(old(data)@.len() as int, data@.len() as int) ==\n          self.len().ghost_serialize() +\n            self@.subrange(0, i as int).fold_left(Seq::<u8>::empty(), |acc: Seq<u8>, x: T| acc + x.ghost_serialize())) by {\n          let s = self@;\n          let emp = Seq::<u8>::empty();\n          let accf = |acc: Seq<u8>, x: T| acc + x.ghost_serialize();\n          let f = |x: T| x.ghost_serialize();\n          let t = s.subrange(0, i as int);\n\n          assert(accf =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n          assert(t.subrange(0, t.len() - 1) =~= s.subrange(0, i - 1));\n          seq_lib_v::lemma_seq_fold_left_append_right(t, emp, f);\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              s.subrange(0, (i - 1) as int).fold_left(emp, accf) +\n              s.index((i - 1) as int).ghost_serialize()\n          );\n          assert(\n            data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.len().ghost_serialize() +\n              t.fold_left(emp, accf)\n          );\n        }\n      }\n    }\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n  }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/marshal_v.rs", "line_number": 747, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "serialize", "mutation_type": "remove_invariant", "fix_description": "Add invariant: i <= self.len()", "synthetic": true}}
{"id": "task_c_delegation_map_v_sorted_subrange_152_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\nproof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    ensures\n        sorted(s.subrange(i, j)),\n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "proof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    ensures\n        sorted(s.subrange(i, j)),\n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}", "broken_code": "proof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    ensures\n        sorted(s.subrange(i, j)),\n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}", "fixed_code": "proof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    ensures\n        sorted(s.subrange(i, j)),\n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 93, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "sorted_subrange", "mutation_type": "remove_requires", "fix_description": "Add requires: 0 <= i <= j <= s.len(), sorted(s), ensures sorted(s.subrange(i, j))", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_truncate_8_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "broken_code": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "fixed_code": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 150, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "truncate", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_to_set_singleton_auto_166_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_to_set_singleton_auto<A>()\n\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}", "broken_code": "\npub proof fn lemma_to_set_singleton_auto<A>()\n\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}", "fixed_code": "\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 273, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_to_set_singleton_auto", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: A| #[trigger] seq![x].to_set() == set![x]", "synthetic": true}}
{"id": "task_c_endpoint_hashmap_t_swap_69_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn swap<'a>(&'a mut self, key: &EndPoint, updated_value: &'a mut V, default_value: V)\n     key@, *old(updated_value), *updated_value, default_value),\n    {\n        match self.m.get_mut(key) {\n            Some(v) => core::mem::swap(v, updated_value),\n            None => {\n                let mut swap_tmp = default_value;\n                core::mem::swap(&mut swap_tmp, updated_value);\n                self.put(key, swap_tmp);\n            }\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn swap<'a>(&'a mut self, key: &EndPoint, updated_value: &'a mut V, default_value: V)\n    ensures\n        Self::swap_spec(old(self)@, self@, key@, *old(updated_value), *updated_value, default_value),\n    {\n        match self.m.get_mut(key) {\n            Some(v) => core::mem::swap(v, updated_value),\n            None => {\n                let mut swap_tmp = default_value;\n                core::mem::swap(&mut swap_tmp, updated_value);\n                self.put(key, swap_tmp);\n            }\n        }\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn swap<'a>(&'a mut self, key: &EndPoint, updated_value: &'a mut V, default_value: V)\n     key@, *old(updated_value), *updated_value, default_value),\n    {\n        match self.m.get_mut(key) {\n            Some(v) => core::mem::swap(v, updated_value),\n            None => {\n                let mut swap_tmp = default_value;\n                core::mem::swap(&mut swap_tmp, updated_value);\n                self.put(key, swap_tmp);\n            }\n        }\n    }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn swap<'a>(&'a mut self, key: &EndPoint, updated_value: &'a mut V, default_value: V)\n    ensures\n        Self::swap_spec(old(self)@, self@, key@, *old(updated_value), *updated_value, default_value),\n    {\n        match self.m.get_mut(key) {\n            Some(v) => core::mem::swap(v, updated_value),\n            None => {\n                let mut swap_tmp = default_value;\n                core::mem::swap(&mut swap_tmp, updated_value);\n                self.put(key, swap_tmp);\n            }\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/endpoint_hashmap_t.rs", "line_number": 99, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "swap", "mutation_type": "remove_ensures", "fix_description": "Add ensures: Self::swap_spec(old(self)@, self@, key@, *old(updated_value), *updated_value, default_value)", "synthetic": true}}
{"id": "task_c_delegation_map_v_vec_erase_153_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "broken_code": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "fixed_code": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 420, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "vec_erase", "mutation_type": "remove_requires", "fix_description": "Add requires: start <= end <= old(v).len(), ensures true, v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int)", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_retransmit_un_acked_packets_for_dst_17_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  \n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "broken_code": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  \n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "fixed_code": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 101, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "retransmit_un_acked_packets_for_dst", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= i <= ack_state.un_acked.len()", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_get_request_91_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n         sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n        ensures  self.next_get_request_postconditions(*old(self), sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "broken_code": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n         sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "fixed_code": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n        ensures  self.next_get_request_postconditions(*old(self), sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1068, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_get_request", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.next_get_request_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_mind_the_gap_128_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn mind_the_gap(self)\n         z) && #[trigger] y.lt_spec(x) ==> #[trigger] self.gap(w, z),\n            forall|w, x, y: KeyIterator<K>, z| #[trigger] self.gap(w, x) && y.geq_spec(w) && x.geq_spec(z) ==> #[trigger] self.gap(y, z),\n            forall|l:KeyIterator<K>, k, m| #[trigger] self.gap(k, m) ==> !(k.lt_spec(l) && l.lt_spec(m) && #[trigger] self@.contains_key(*l.get()))\n    {\n        K::cmp_properties();\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn mind_the_gap(self)\n        ensures\n            forall|w, x, y, z| self.gap(w, x) && self.gap(y, z) && #[trigger] y.lt_spec(x) ==> #[trigger] self.gap(w, z),\n            forall|w, x, y: KeyIterator<K>, z| #[trigger] self.gap(w, x) && y.geq_spec(w) && x.geq_spec(z) ==> #[trigger] self.gap(y, z),\n            forall|l:KeyIterator<K>, k, m| #[trigger] self.gap(k, m) ==> !(k.lt_spec(l) && l.lt_spec(m) && #[trigger] self@.contains_key(*l.get()))\n    {\n        K::cmp_properties();\n    }", "broken_code": "\n    proof fn mind_the_gap(self)\n         z) && #[trigger] y.lt_spec(x) ==> #[trigger] self.gap(w, z),\n            forall|w, x, y: KeyIterator<K>, z| #[trigger] self.gap(w, x) && y.geq_spec(w) && x.geq_spec(z) ==> #[trigger] self.gap(y, z),\n            forall|l:KeyIterator<K>, k, m| #[trigger] self.gap(k, m) ==> !(k.lt_spec(l) && l.lt_spec(m) && #[trigger] self@.contains_key(*l.get()))\n    {\n        K::cmp_properties();\n    }", "fixed_code": "\n    proof fn mind_the_gap(self)\n        ensures\n            forall|w, x, y, z| self.gap(w, x) && self.gap(y, z) && #[trigger] y.lt_spec(x) ==> #[trigger] self.gap(w, z),\n            forall|w, x, y: KeyIterator<K>, z| #[trigger] self.gap(w, x) && y.geq_spec(w) && x.geq_spec(z) ==> #[trigger] self.gap(y, z),\n            forall|l:KeyIterator<K>, k, m| #[trigger] self.gap(k, m) ==> !(k.lt_spec(l) && l.lt_spec(m) && #[trigger] self@.contains_key(*l.get()))\n    {\n        K::cmp_properties();\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 486, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "mind_the_gap", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall|w, x, y, z| self.gap(w, x) && self.gap(y, z) && #[trigger] y.lt_spec(x) ==> #[trigger] self.gap(w, z), forall|w, x, y: KeyIterator<K>, z| #[trigger] self.gap(w, x) && y.geq_spec(w) && x.geq_spec(z) ==> #[trigger] self.gap(y, z), forall|l:KeyIterator<K>, k, m| #[trigger] self.gap(k, m) ==> !(k.lt_spec(l) && l.lt_spec(m) && #[trigger] self@.contains_key(*l.get()))", "synthetic": true}}
{"id": "task_c_io_t_valid_physical_address_57_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn valid_physical_address(&self) -> (out: bool)\n    \n    {\n        self.id.len() < 0x100000\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn valid_physical_address(&self) -> (out: bool)\n    ensures\n        out == self@.valid_physical_address(),\n    {\n        self.id.len() < 0x100000\n    }", "broken_code": "    pub fn valid_physical_address(&self) -> (out: bool)\n    \n    {\n        self.id.len() < 0x100000\n    }", "fixed_code": "    pub fn valid_physical_address(&self) -> (out: bool)\n    ensures\n        out == self@.valid_physical_address(),\n    {\n        self.id.len() < 0x100000\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/io_t.rs", "line_number": 70, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "valid_physical_address", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out == self@.valid_physical_address()", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_internal_142_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n        ensures ({\n            let (id, glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }\n```\n\nProvide the fixed code:", "target_text": "    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n        ensures ({\n            let (id, glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }", "broken_code": "    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n        ensures ({\n            let (id, glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }", "fixed_code": "    fn get_internal(&self, k: &K) -> (res: (ID, Ghost<KeyIterator<K>>))\n        requires\n            self.valid(),\n        ensures ({\n            let (id, glb) = res;\n            &&& id@ == self@[*k]\n            &&& self.lows.greatest_lower_bound_spec(KeyIterator::new_spec(*k), glb@)\n            &&& id@.valid_physical_address()\n        }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1076, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get_internal", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), ensures (", "synthetic": true}}
{"id": "task_c_host_impl_v_real_next_impl_100_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn real_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        proof { old(self).delegation_map.valid_implies_complete(); }\n        let cur_action_index = self.next_action_index;\n        let rc;\n        if cur_action_index == 0 {\n            rc = self.receive_packet_next(netc);\n        } else if cur_action_index == 1 {\n            let ghost old_self: HostState = *self;\n            let ghost old_netc: NetClient = *netc;\n            rc = self.process_received_packet_next_impl(netc);\n            proof {\n                let (ok, res) = rc; {\n                    if ok {\n                        if process_received_packet_next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)) {\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::ProcessReceivedPacket{})); // establish exists |step| next_step...\n                        }\n                        else {\n                            assert (ignore_nonsensical_delegation_packet(old_self@, self@,\n                                                                         abstractify_raw_log_to_ios(res@.ios)));\n                            // establish exists |step| next_step...\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::IgnoreNonsensicalDelegationPacket{}));\n                        }\n                        assert (host_protocol_t::next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)));\n                    }\n                }\n            }\n        } else if cur_action_index == 2 {\n            self.resend_count = (self.resend_count + 1) % 100000000;\n            if (self.resend_count == 0) {\n                rc = self.host_noreceive_noclock_next(netc);\n                assert( rc.0 ==> Self::next(old(self)@, self@, rc.1@.ios) );\n            } else {\n                rc = (true, make_empty_event_results());\n                assert( next_step(old(self)@, self@, abstractify_raw_log_to_ios(rc.1@.ios), Step::SpontaneouslyRetransmit{}));    // witness\n            }\n        } else {\n            assert (false);\n            rc = unreached()\n        }\n\n        if !rc.0 { return rc; }\n\n        assert(self.invariants(&netc.my_end_point()));\n        self.next_action_index = (self.next_action_index + 1) % 3;\n        proof {\n            let (ok, res) = rc;\n            assert(res@.event_seq() == res@.ios);\n            assert((ok || res@.sends.len()>0) ==> netc.history() == old(netc).history() + res@.event_seq());\n        }\n        rc\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn real_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        proof { old(self).delegation_map.valid_implies_complete(); }\n        let cur_action_index = self.next_action_index;\n        let rc;\n        if cur_action_index == 0 {\n            rc = self.receive_packet_next(netc);\n        } else if cur_action_index == 1 {\n            let ghost old_self: HostState = *self;\n            let ghost old_netc: NetClient = *netc;\n            rc = self.process_received_packet_next_impl(netc);\n            proof {\n                let (ok, res) = rc; {\n                    if ok {\n                        if process_received_packet_next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)) {\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::ProcessReceivedPacket{})); // establish exists |step| next_step...\n                        }\n                        else {\n                            assert (ignore_nonsensical_delegation_packet(old_self@, self@,\n                                                                         abstractify_raw_log_to_ios(res@.ios)));\n                            // establish exists |step| next_step...\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::IgnoreNonsensicalDelegationPacket{}));\n                        }\n                        assert (host_protocol_t::next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)));\n                    }\n                }\n            }\n        } else if cur_action_index == 2 {\n            self.resend_count = (self.resend_count + 1) % 100000000;\n            if (self.resend_count == 0) {\n                rc = self.host_noreceive_noclock_next(netc);\n                assert( rc.0 ==> Self::next(old(self)@, self@, rc.1@.ios) );\n            } else {\n                rc = (true, make_empty_event_results());\n                assert( next_step(old(self)@, self@, abstractify_raw_log_to_ios(rc.1@.ios), Step::SpontaneouslyRetransmit{}));    // witness\n            }\n        } else {\n            assert (false);\n            rc = unreached()\n        }\n\n        if !rc.0 { return rc; }\n\n        assert(self.invariants(&netc.my_end_point()));\n        self.next_action_index = (self.next_action_index + 1) % 3;\n        proof {\n            let (ok, res) = rc;\n            assert(res@.event_seq() == res@.ios);\n            assert((ok || res@.sends.len()>0) ==> netc.history() == old(netc).history() + res@.event_seq());\n        }\n        rc\n    }", "broken_code": "\n    pub fn real_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        proof { old(self).delegation_map.valid_implies_complete(); }\n        let cur_action_index = self.next_action_index;\n        let rc;\n        if cur_action_index == 0 {\n            rc = self.receive_packet_next(netc);\n        } else if cur_action_index == 1 {\n            let ghost old_self: HostState = *self;\n            let ghost old_netc: NetClient = *netc;\n            rc = self.process_received_packet_next_impl(netc);\n            proof {\n                let (ok, res) = rc; {\n                    if ok {\n                        if process_received_packet_next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)) {\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::ProcessReceivedPacket{})); // establish exists |step| next_step...\n                        }\n                        else {\n                            assert (ignore_nonsensical_delegation_packet(old_self@, self@,\n                                                                         abstractify_raw_log_to_ios(res@.ios)));\n                            // establish exists |step| next_step...\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::IgnoreNonsensicalDelegationPacket{}));\n                        }\n                        assert (host_protocol_t::next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)));\n                    }\n                }\n            }\n        } else if cur_action_index == 2 {\n            self.resend_count = (self.resend_count + 1) % 100000000;\n            if (self.resend_count == 0) {\n                rc = self.host_noreceive_noclock_next(netc);\n                assert( rc.0 ==> Self::next(old(self)@, self@, rc.1@.ios) );\n            } else {\n                rc = (true, make_empty_event_results());\n                assert( next_step(old(self)@, self@, abstractify_raw_log_to_ios(rc.1@.ios), Step::SpontaneouslyRetransmit{}));    // witness\n            }\n        } else {\n            assert (false);\n            rc = unreached()\n        }\n\n        if !rc.0 { return rc; }\n\n        assert(self.invariants(&netc.my_end_point()));\n        self.next_action_index = (self.next_action_index + 1) % 3;\n        proof {\n            let (ok, res) = rc;\n            assert(res@.event_seq() == res@.ios);\n            assert((ok || res@.sends.len()>0) ==> netc.history() == old(netc).history() + res@.event_seq());\n        }\n        rc\n    }", "fixed_code": "\n    pub fn real_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        proof { old(self).delegation_map.valid_implies_complete(); }\n        let cur_action_index = self.next_action_index;\n        let rc;\n        if cur_action_index == 0 {\n            rc = self.receive_packet_next(netc);\n        } else if cur_action_index == 1 {\n            let ghost old_self: HostState = *self;\n            let ghost old_netc: NetClient = *netc;\n            rc = self.process_received_packet_next_impl(netc);\n            proof {\n                let (ok, res) = rc; {\n                    if ok {\n                        if process_received_packet_next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)) {\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::ProcessReceivedPacket{})); // establish exists |step| next_step...\n                        }\n                        else {\n                            assert (ignore_nonsensical_delegation_packet(old_self@, self@,\n                                                                         abstractify_raw_log_to_ios(res@.ios)));\n                            // establish exists |step| next_step...\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::IgnoreNonsensicalDelegationPacket{}));\n                        }\n                        assert (host_protocol_t::next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)));\n                    }\n                }\n            }\n        } else if cur_action_index == 2 {\n            self.resend_count = (self.resend_count + 1) % 100000000;\n            if (self.resend_count == 0) {\n                rc = self.host_noreceive_noclock_next(netc);\n                assert( rc.0 ==> Self::next(old(self)@, self@, rc.1@.ios) );\n            } else {\n                rc = (true, make_empty_event_results());\n                assert( next_step(old(self)@, self@, abstractify_raw_log_to_ios(rc.1@.ios), Step::SpontaneouslyRetransmit{}));    // witness\n            }\n        } else {\n            assert (false);\n            rc = unreached()\n        }\n\n        if !rc.0 { return rc; }\n\n        assert(self.invariants(&netc.my_end_point()));\n        self.next_action_index = (self.next_action_index + 1) % 3;\n        proof {\n            let (ok, res) = rc;\n            assert(res@.event_seq() == res@.ios);\n            assert((ok || res@.sends.len()>0) ==> netc.history() == old(netc).history() + res@.event_seq());\n        }\n        rc\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1778, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "real_next_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_do_vec_u8s_match_24_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        \n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "broken_code": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        \n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "fixed_code": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 18, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "do_vec_u8s_match", "mutation_type": "remove_ensures", "fix_description": "Add ensures: eq == (e1@ == e2@)", "synthetic": true}}
{"id": "task_c_host_impl_v_parse_end_point_82_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn parse_end_point(arg: &Arg) -> (out: EndPoint)\n    \n    {\n        EndPoint{id: clone_arg(arg)}\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn parse_end_point(arg: &Arg) -> (out: EndPoint)\n    ensures\n        out@ == host_protocol_t::parse_arg_as_end_point(arg@),\n    {\n        EndPoint{id: clone_arg(arg)}\n    }", "broken_code": "\n    fn parse_end_point(arg: &Arg) -> (out: EndPoint)\n    \n    {\n        EndPoint{id: clone_arg(arg)}\n    }", "fixed_code": "\n    fn parse_end_point(arg: &Arg) -> (out: EndPoint)\n    ensures\n        out@ == host_protocol_t::parse_arg_as_end_point(arg@),\n    {\n        EndPoint{id: clone_arg(arg)}\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 279, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "parse_end_point", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out@ == host_protocol_t::parse_arg_as_end_point(arg@)", "synthetic": true}}
{"id": "task_c_cmessage_v_is_message_marshallable_74_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n  pub fn is_message_marshallable(&self) -> (b: bool)\n      \n          CMessage::SetRequest{ k , v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Reply{ k, v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Redirect{ k, id } => is_key_valid(k) && id.valid_physical_address(),\n          CMessage::Shard{ kr, recipient } => recipient.valid_physical_address() && kr.lo.lt(&kr.hi),\n          CMessage::Delegate{ range, h } => range.lo.lt(&range.hi) && h.valid(),\n      }\n  }\n```\n\nProvide the fixed code:", "target_text": "  pub fn is_message_marshallable(&self) -> (b: bool)\n      ensures  b == self.message_marshallable()\n  {\n      match self {\n          CMessage::GetRequest{ k } => is_key_valid(k),\n          CMessage::SetRequest{ k , v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Reply{ k, v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Redirect{ k, id } => is_key_valid(k) && id.valid_physical_address(),\n          CMessage::Shard{ kr, recipient } => recipient.valid_physical_address() && kr.lo.lt(&kr.hi),\n          CMessage::Delegate{ range, h } => range.lo.lt(&range.hi) && h.valid(),\n      }\n  }", "broken_code": "  pub fn is_message_marshallable(&self) -> (b: bool)\n      \n          CMessage::SetRequest{ k , v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Reply{ k, v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Redirect{ k, id } => is_key_valid(k) && id.valid_physical_address(),\n          CMessage::Shard{ kr, recipient } => recipient.valid_physical_address() && kr.lo.lt(&kr.hi),\n          CMessage::Delegate{ range, h } => range.lo.lt(&range.hi) && h.valid(),\n      }\n  }", "fixed_code": "  pub fn is_message_marshallable(&self) -> (b: bool)\n      ensures  b == self.message_marshallable()\n  {\n      match self {\n          CMessage::GetRequest{ k } => is_key_valid(k),\n          CMessage::SetRequest{ k , v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Reply{ k, v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Redirect{ k, id } => is_key_valid(k) && id.valid_physical_address(),\n          CMessage::Shard{ kr, recipient } => recipient.valid_physical_address() && kr.lo.lt(&kr.hi),\n          CMessage::Delegate{ range, h } => range.lo.lt(&range.hi) && h.valid(),\n      }\n  }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 153, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_message_marshallable", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.message_marshallable()", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_lemma_un_acked_messages_for_dests_empty_16_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n        requires dests == Set::<AbstractEndPoint>::empty()\n         dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n        requires dests == Set::<AbstractEndPoint>::empty()\n        ensures self.un_acked_messages_for_dests(src, dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }", "broken_code": "\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n        requires dests == Set::<AbstractEndPoint>::empty()\n         dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }", "fixed_code": "\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n        requires dests == Set::<AbstractEndPoint>::empty()\n        ensures self.un_acked_messages_for_dests(src, dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 378, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lemma_un_acked_messages_for_dests_empty", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.un_acked_messages_for_dests(src, dests) == Set::<Packet>::empty()", "synthetic": true}}
{"id": "task_c_io_t_reset_58_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }", "broken_code": "    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }", "fixed_code": "    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/io_t.rs", "line_number": 224, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "reset", "mutation_type": "remove_requires", "fix_description": "Add requires: from_trusted_code() ensures self.state() is Receiving, self.my_end_point() == old(self).my_end_point()", "synthetic": true}}
{"id": "task_c_delegation_map_v_all_keys_agree_148_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n         &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }", "broken_code": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n         &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }", "fixed_code": "\n    proof fn all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i <= hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        self.almost_all_keys_agree(lo, hi, id);\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1388, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "all_keys_agree", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id), decreases hi - lo", "synthetic": true}}
{"id": "task_c_host_impl_v_extract_range_impl_103_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\nfn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\n\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}\n```\n\nProvide the fixed code:", "target_text": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "broken_code": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\n\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "fixed_code": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 212, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "extract_range_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: ext@ =~= extract_range(h@, *kr)", "synthetic": true}}
{"id": "task_c_delegation_map_v_is_ne_109_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn is_ne(self) -> (b:bool)\n        \n    {\n        !matches!(self, Ordering::Equal)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn is_ne(self) -> (b:bool)\n        ensures b == self.ne(),\n    {\n        !matches!(self, Ordering::Equal)\n    }", "broken_code": "\n    pub fn is_ne(self) -> (b:bool)\n        \n    {\n        !matches!(self, Ordering::Equal)\n    }", "fixed_code": "\n    pub fn is_ne(self) -> (b:bool)\n        ensures b == self.ne(),\n    {\n        !matches!(self, Ordering::Equal)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 48, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_ne", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.ne()", "synthetic": true}}
{"id": "task_c_host_impl_v_effect_of_delegation_map_set_93_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }", "broken_code": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }", "fixed_code": "\n    proof fn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n        requires\n            pre.valid(),\n            post.valid(),\n            forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,\n            forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n       ensures\n           AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>{ lo: *lo, hi: *hi }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1333, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "effect_of_delegation_map_set", "mutation_type": "remove_requires", "fix_description": "Add requires: pre.valid(), post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()], ensures AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>", "synthetic": true}}
{"id": "task_c_hashmap_t_remove_43_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn remove(&mut self, key: &CKey)\n      \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn remove(&mut self, key: &CKey)\n      ensures self@ == old(self)@.remove(*key)\n    {\n        panic!()\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn remove(&mut self, key: &CKey)\n      ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn remove(&mut self, key: &CKey)\n      ensures self@ == old(self)@.remove(*key)\n    {\n        panic!()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 58, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "remove", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@ == old(self)@.remove(*key)", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_same_view_same_marshalable_23_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\n\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "broken_code": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\n\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "fixed_code": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 26, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "same_view_same_marshalable", "mutation_type": "remove_ensures", "fix_description": "Add ensures: x.is_marshalable() == y.is_marshalable()", "synthetic": true}}
{"id": "task_c_seq_lib_v_some_differing_index_for_unequal_seqs_173_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}", "broken_code": "\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}", "fixed_code": "\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/seq_lib_v.rs", "line_number": 251, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "some_differing_index_for_unequal_seqs", "mutation_type": "remove_ensures", "fix_description": "Add ensures: 0 <= i < s1.len(), s1[i] != s2[i]", "synthetic": true}}
{"id": "task_c_delegation_map_v_values_agree_133_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            invariant \n                lo <= i,\n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            invariant \n                lo <= i,\n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }", "broken_code": "    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            invariant \n                lo <= i,\n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }", "fixed_code": "    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            invariant \n                lo <= i,\n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 566, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "values_agree", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), 0 <= lo <= hi < self.keys@.len(), ensures ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@, !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@))", "synthetic": true}}
{"id": "task_c_delegation_map_v_extend_range_consistent_145_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        \n    {\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }", "broken_code": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        \n    {\n    }", "fixed_code": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1359, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "extend_range_consistent", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.range_consistent(x, z, dst)", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_delegate_95_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        \n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "broken_code": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        \n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "fixed_code": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1377, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_delegate", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).next_delegate_preconditions(), ensures self.next_delegate_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_host_impl_v_parse_command_line_configuration_84_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn parse_command_line_configuration(args: &Args, me: EndPoint) -> (rc: Option<Constants>)\n    \n            Some(c) => {\n                &&& abstract_end_points.is_some()\n                &&& abstract_end_points.unwrap().len() > 0\n                &&& seq_is_unique(abstract_end_points.unwrap())\n                &&& c@ == AbstractConstants{\n                    root_identity: abstract_end_points.unwrap()[0],\n                    host_ids: abstract_end_points.unwrap(),\n                    params: AbstractParameters::static_params(),\n                    me: me@ }\n            }}}\n```\n\nProvide the fixed code:", "target_text": "    fn parse_command_line_configuration(args: &Args, me: EndPoint) -> (rc: Option<Constants>)\n    ensures ({\n        let abstract_end_points = parse_args(abstractify_args(*args));\n        match rc {\n            None => {\n                ||| abstract_end_points is None\n                ||| abstract_end_points.unwrap().len()==0\n                ||| !seq_is_unique(abstract_end_points.unwrap())\n            },\n            Some(c) => {\n                &&& abstract_end_points.is_some()\n                &&& abstract_end_points.unwrap().len() > 0\n                &&& seq_is_unique(abstract_end_points.unwrap())\n                &&& c@ == AbstractConstants{\n                    root_identity: abstract_end_points.unwrap()[0],\n                    host_ids: abstract_end_points.unwrap(),\n                    params: AbstractParameters::static_params(),\n                    me: me@ }\n            }}}", "broken_code": "    fn parse_command_line_configuration(args: &Args, me: EndPoint) -> (rc: Option<Constants>)\n    \n            Some(c) => {\n                &&& abstract_end_points.is_some()\n                &&& abstract_end_points.unwrap().len() > 0\n                &&& seq_is_unique(abstract_end_points.unwrap())\n                &&& c@ == AbstractConstants{\n                    root_identity: abstract_end_points.unwrap()[0],\n                    host_ids: abstract_end_points.unwrap(),\n                    params: AbstractParameters::static_params(),\n                    me: me@ }\n            }}}", "fixed_code": "    fn parse_command_line_configuration(args: &Args, me: EndPoint) -> (rc: Option<Constants>)\n    ensures ({\n        let abstract_end_points = parse_args(abstractify_args(*args));\n        match rc {\n            None => {\n                ||| abstract_end_points is None\n                ||| abstract_end_points.unwrap().len()==0\n                ||| !seq_is_unique(abstract_end_points.unwrap())\n            },\n            Some(c) => {\n                &&& abstract_end_points.is_some()\n                &&& abstract_end_points.unwrap().len() > 0\n                &&& seq_is_unique(abstract_end_points.unwrap())\n                &&& c@ == AbstractConstants{\n                    root_identity: abstract_end_points.unwrap()[0],\n                    host_ids: abstract_end_points.unwrap(),\n                    params: AbstractParameters::static_params(),\n                    me: me@ }\n            }}}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 331, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "parse_command_line_configuration", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (", "synthetic": true}}
{"id": "task_c_main_t_sht_main_2_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\npub fn sht_main(netc: NetClient, args: Args) -> Result<(), IronError>\n    requires\n        netc.valid(),\n        netc.state() is Receiving,\n        crate::io_t::from_trusted_code()\n{\n    let mut netc = netc;    // Verus does not support `mut` arguments\n\n//    let mut host_c: host_protocol_t::Constants;\n//    let mut host: host_protocol_t::Variables;\n\n    let opt_host_state: Option<HostState> = HostState::init_impl(&netc, &args);\n    let mut host_state = match opt_host_state {\n        None => { return Err(IronError{}) },\n        Some(thing) => thing,\n    };\n    let mut ok: bool = true;\n\n//    let config = HostState::parse_command_line_configuration(args);\n    let end_point = netc.get_my_end_point();\n    // This init function in Dafny is in Impl/LiveSHT/Host.i.\n    // It calls LScheduler_Init, which does some scheduly stuff (which I'm hoping\n    // we can ignore) and then calls Protocol/SHT/Host.i/Host_Init.\n    assert(crate::host_protocol_t::init(host_state@, end_point@, abstractify_args(args)));\n\n    while (ok)\n         // this predicate's value cannot change, but has to be explicitly imported into the loop invariant\n        ok ==> host_state.invariants(&netc.my_end_point()),\n        ok == netc.ok(),\n        ok ==> netc.state() is Receiving,\n    {\n      // no need for decreases * because exec functions don't termination-check\n\n      let old_net_history: Ghost<History> = Ghost(netc.history());\n      let old_state: Ghost<HostState> = Ghost(host_state);\n\n      let (shadow_ok, event_results) = host_state.next_impl(&mut netc);\n      ok = shadow_ok;\n\n      if ok {\n        assert(host_state.invariants(&netc.my_end_point()));\n\n        //NB these assertions are just here to help the spec auditor see we're\n        //doing the right thing. They duplicate the ensures on the next_impl trait method in\n        //host_impl_t.\n\n        // Correctly executed one action\n        assert(HostState::next(old_state@@, host_state@, event_results@.ios));\n\n        // Connect the low-level IO events to the spec-level IO events\n        assert(event_results@.event_seq() == event_results@.ios);\n\n        // The event_seq obligation enable us to apply reduction. But we shouldn't need to separate these\n        // events out anymore (relative to ironfleet) now that we're enforcing this ordering in the\n        // NetClient interface.\n        assert(netc.history() == old_net_history@ + event_results@.event_seq());\n        assert(event_results@.well_typed_events());\n\n        // Reset to allow receiving for the next atomic step.\n        netc.reset();\n      }\n    }\n```\n\nProvide the fixed code:", "target_text": "pub fn sht_main(netc: NetClient, args: Args) -> Result<(), IronError>\n    requires\n        netc.valid(),\n        netc.state() is Receiving,\n        crate::io_t::from_trusted_code()\n{\n    let mut netc = netc;    // Verus does not support `mut` arguments\n\n//    let mut host_c: host_protocol_t::Constants;\n//    let mut host: host_protocol_t::Variables;\n\n    let opt_host_state: Option<HostState> = HostState::init_impl(&netc, &args);\n    let mut host_state = match opt_host_state {\n        None => { return Err(IronError{}) },\n        Some(thing) => thing,\n    };\n    let mut ok: bool = true;\n\n//    let config = HostState::parse_command_line_configuration(args);\n    let end_point = netc.get_my_end_point();\n    // This init function in Dafny is in Impl/LiveSHT/Host.i.\n    // It calls LScheduler_Init, which does some scheduly stuff (which I'm hoping\n    // we can ignore) and then calls Protocol/SHT/Host.i/Host_Init.\n    assert(crate::host_protocol_t::init(host_state@, end_point@, abstractify_args(args)));\n\n    while (ok)\n      invariant\n        crate::io_t::from_trusted_code(),   // this predicate's value cannot change, but has to be explicitly imported into the loop invariant\n        ok ==> host_state.invariants(&netc.my_end_point()),\n        ok == netc.ok(),\n        ok ==> netc.state() is Receiving,\n    {\n      // no need for decreases * because exec functions don't termination-check\n\n      let old_net_history: Ghost<History> = Ghost(netc.history());\n      let old_state: Ghost<HostState> = Ghost(host_state);\n\n      let (shadow_ok, event_results) = host_state.next_impl(&mut netc);\n      ok = shadow_ok;\n\n      if ok {\n        assert(host_state.invariants(&netc.my_end_point()));\n\n        //NB these assertions are just here to help the spec auditor see we're\n        //doing the right thing. They duplicate the ensures on the next_impl trait method in\n        //host_impl_t.\n\n        // Correctly executed one action\n        assert(HostState::next(old_state@@, host_state@, event_results@.ios));\n\n        // Connect the low-level IO events to the spec-level IO events\n        assert(event_results@.event_seq() == event_results@.ios);\n\n        // The event_seq obligation enable us to apply reduction. But we shouldn't need to separate these\n        // events out anymore (relative to ironfleet) now that we're enforcing this ordering in the\n        // NetClient interface.\n        assert(netc.history() == old_net_history@ + event_results@.event_seq());\n        assert(event_results@.well_typed_events());\n\n        // Reset to allow receiving for the next atomic step.\n        netc.reset();\n      }\n    }", "broken_code": "pub fn sht_main(netc: NetClient, args: Args) -> Result<(), IronError>\n    requires\n        netc.valid(),\n        netc.state() is Receiving,\n        crate::io_t::from_trusted_code()\n{\n    let mut netc = netc;    // Verus does not support `mut` arguments\n\n//    let mut host_c: host_protocol_t::Constants;\n//    let mut host: host_protocol_t::Variables;\n\n    let opt_host_state: Option<HostState> = HostState::init_impl(&netc, &args);\n    let mut host_state = match opt_host_state {\n        None => { return Err(IronError{}) },\n        Some(thing) => thing,\n    };\n    let mut ok: bool = true;\n\n//    let config = HostState::parse_command_line_configuration(args);\n    let end_point = netc.get_my_end_point();\n    // This init function in Dafny is in Impl/LiveSHT/Host.i.\n    // It calls LScheduler_Init, which does some scheduly stuff (which I'm hoping\n    // we can ignore) and then calls Protocol/SHT/Host.i/Host_Init.\n    assert(crate::host_protocol_t::init(host_state@, end_point@, abstractify_args(args)));\n\n    while (ok)\n         // this predicate's value cannot change, but has to be explicitly imported into the loop invariant\n        ok ==> host_state.invariants(&netc.my_end_point()),\n        ok == netc.ok(),\n        ok ==> netc.state() is Receiving,\n    {\n      // no need for decreases * because exec functions don't termination-check\n\n      let old_net_history: Ghost<History> = Ghost(netc.history());\n      let old_state: Ghost<HostState> = Ghost(host_state);\n\n      let (shadow_ok, event_results) = host_state.next_impl(&mut netc);\n      ok = shadow_ok;\n\n      if ok {\n        assert(host_state.invariants(&netc.my_end_point()));\n\n        //NB these assertions are just here to help the spec auditor see we're\n        //doing the right thing. They duplicate the ensures on the next_impl trait method in\n        //host_impl_t.\n\n        // Correctly executed one action\n        assert(HostState::next(old_state@@, host_state@, event_results@.ios));\n\n        // Connect the low-level IO events to the spec-level IO events\n        assert(event_results@.event_seq() == event_results@.ios);\n\n        // The event_seq obligation enable us to apply reduction. But we shouldn't need to separate these\n        // events out anymore (relative to ironfleet) now that we're enforcing this ordering in the\n        // NetClient interface.\n        assert(netc.history() == old_net_history@ + event_results@.event_seq());\n        assert(event_results@.well_typed_events());\n\n        // Reset to allow receiving for the next atomic step.\n        netc.reset();\n      }\n    }", "fixed_code": "pub fn sht_main(netc: NetClient, args: Args) -> Result<(), IronError>\n    requires\n        netc.valid(),\n        netc.state() is Receiving,\n        crate::io_t::from_trusted_code()\n{\n    let mut netc = netc;    // Verus does not support `mut` arguments\n\n//    let mut host_c: host_protocol_t::Constants;\n//    let mut host: host_protocol_t::Variables;\n\n    let opt_host_state: Option<HostState> = HostState::init_impl(&netc, &args);\n    let mut host_state = match opt_host_state {\n        None => { return Err(IronError{}) },\n        Some(thing) => thing,\n    };\n    let mut ok: bool = true;\n\n//    let config = HostState::parse_command_line_configuration(args);\n    let end_point = netc.get_my_end_point();\n    // This init function in Dafny is in Impl/LiveSHT/Host.i.\n    // It calls LScheduler_Init, which does some scheduly stuff (which I'm hoping\n    // we can ignore) and then calls Protocol/SHT/Host.i/Host_Init.\n    assert(crate::host_protocol_t::init(host_state@, end_point@, abstractify_args(args)));\n\n    while (ok)\n      invariant\n        crate::io_t::from_trusted_code(),   // this predicate's value cannot change, but has to be explicitly imported into the loop invariant\n        ok ==> host_state.invariants(&netc.my_end_point()),\n        ok == netc.ok(),\n        ok ==> netc.state() is Receiving,\n    {\n      // no need for decreases * because exec functions don't termination-check\n\n      let old_net_history: Ghost<History> = Ghost(netc.history());\n      let old_state: Ghost<HostState> = Ghost(host_state);\n\n      let (shadow_ok, event_results) = host_state.next_impl(&mut netc);\n      ok = shadow_ok;\n\n      if ok {\n        assert(host_state.invariants(&netc.my_end_point()));\n\n        //NB these assertions are just here to help the spec auditor see we're\n        //doing the right thing. They duplicate the ensures on the next_impl trait method in\n        //host_impl_t.\n\n        // Correctly executed one action\n        assert(HostState::next(old_state@@, host_state@, event_results@.ios));\n\n        // Connect the low-level IO events to the spec-level IO events\n        assert(event_results@.event_seq() == event_results@.ios);\n\n        // The event_seq obligation enable us to apply reduction. But we shouldn't need to separate these\n        // events out anymore (relative to ironfleet) now that we're enforcing this ordering in the\n        // NetClient interface.\n        assert(netc.history() == old_net_history@ + event_results@.event_seq());\n        assert(event_results@.well_typed_events());\n\n        // Reset to allow receiving for the next atomic step.\n        netc.reset();\n      }\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/main_t.rs", "line_number": 28, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/main_t.rs", "function_name": "sht_main", "mutation_type": "remove_invariant", "fix_description": "Add invariant: crate::io_t::from_trusted_code()", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_clone_option_end_point_30_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        \n                None => cloned_oep is None,\n            }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        ensures\n            match oep {\n                Some(ep) => cloned_oep.is_some() && ep@ == cloned_oep->0@,\n                None => cloned_oep is None,\n            }", "broken_code": "\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        \n                None => cloned_oep is None,\n            }", "fixed_code": "\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        ensures\n            match oep {\n                Some(ep) => cloned_oep.is_some() && ep@ == cloned_oep->0@,\n                None => cloned_oep is None,\n            }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 144, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_option_end_point", "mutation_type": "remove_ensures", "fix_description": "Add ensures: match oep", "synthetic": true}}
{"id": "task_c_hashmap_t_valid_50_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n        \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n        ensures b == valid_hashtable(self@)\n    {\n        panic!()\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n        ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n        ensures b == valid_hashtable(self@)\n    {\n        panic!()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 159, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "valid", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == valid_hashtable(self@)", "synthetic": true}}
{"id": "task_c_hashmap_t_insert_42_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: CKey, value: Vec<u8>)\n       value@)\n    {\n        //TODO: Soundness issue needs careful examination: What properties must we demand of Key\n        //for this ensures to be correct? If Key has a nondeterministic hash, for example, this\n        //ensures will be false.\n        self.m.insert(key, value);\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: CKey, value: Vec<u8>)\n      ensures self@ == old(self)@.insert(key, value@)\n    {\n        //TODO: Soundness issue needs careful examination: What properties must we demand of Key\n        //for this ensures to be correct? If Key has a nondeterministic hash, for example, this\n        //ensures will be false.\n        self.m.insert(key, value);\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: CKey, value: Vec<u8>)\n       value@)\n    {\n        //TODO: Soundness issue needs careful examination: What properties must we demand of Key\n        //for this ensures to be correct? If Key has a nondeterministic hash, for example, this\n        //ensures will be false.\n        self.m.insert(key, value);\n    }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: CKey, value: Vec<u8>)\n      ensures self@ == old(self)@.insert(key, value@)\n    {\n        //TODO: Soundness issue needs careful examination: What properties must we demand of Key\n        //for this ensures to be correct? If Key has a nondeterministic hash, for example, this\n        //ensures will be false.\n        self.m.insert(key, value);\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 48, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "insert", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@ == old(self)@.insert(key, value@)", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_lemma_seqno_in_un_acked_list_6_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n         k - 1);\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "broken_code": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n         k - 1);\n        }\n    }", "fixed_code": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 124, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lemma_seqno_in_un_acked_list", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k", "synthetic": true}}
{"id": "task_c_cmessage_v_clone_up_to_view_73_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  \n          CMessage::SetRequest{ k , v } => { CMessage::SetRequest{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Reply{ k, v } => { CMessage::Reply{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Redirect{ k, id } => { CMessage::Redirect{ k: k.clone(), id: id.clone_up_to_view() } },\n          CMessage::Shard{ kr, recipient } => { CMessage::Shard{ kr: kr.clone(), recipient: recipient.clone_up_to_view() } },\n          CMessage::Delegate{ range, h } => { CMessage::Delegate{ range: range.clone(), h: h.clone_up_to_view() } },\n      }\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CMessage::GetRequest{ k } => { CMessage::GetRequest{ k: k.clone() } },\n          CMessage::SetRequest{ k , v } => { CMessage::SetRequest{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Reply{ k, v } => { CMessage::Reply{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Redirect{ k, id } => { CMessage::Redirect{ k: k.clone(), id: id.clone_up_to_view() } },\n          CMessage::Shard{ kr, recipient } => { CMessage::Shard{ kr: kr.clone(), recipient: recipient.clone_up_to_view() } },\n          CMessage::Delegate{ range, h } => { CMessage::Delegate{ range: range.clone(), h: h.clone_up_to_view() } },\n      }\n  }", "broken_code": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  \n          CMessage::SetRequest{ k , v } => { CMessage::SetRequest{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Reply{ k, v } => { CMessage::Reply{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Redirect{ k, id } => { CMessage::Redirect{ k: k.clone(), id: id.clone_up_to_view() } },\n          CMessage::Shard{ kr, recipient } => { CMessage::Shard{ kr: kr.clone(), recipient: recipient.clone_up_to_view() } },\n          CMessage::Delegate{ range, h } => { CMessage::Delegate{ range: range.clone(), h: h.clone_up_to_view() } },\n      }\n  }", "fixed_code": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CMessage::GetRequest{ k } => { CMessage::GetRequest{ k: k.clone() } },\n          CMessage::SetRequest{ k , v } => { CMessage::SetRequest{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Reply{ k, v } => { CMessage::Reply{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Redirect{ k, id } => { CMessage::Redirect{ k: k.clone(), id: id.clone_up_to_view() } },\n          CMessage::Shard{ kr, recipient } => { CMessage::Shard{ kr: kr.clone(), recipient: recipient.clone_up_to_view() } },\n          CMessage::Delegate{ range, h } => { CMessage::Delegate{ range: range.clone(), h: h.clone_up_to_view() } },\n      }\n  }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 124, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_up_to_view", "mutation_type": "remove_ensures", "fix_description": "Add ensures: c@ == self@", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_seq_map_values_concat_auto_160_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn seq_map_values_concat_auto<A, B>()\n f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn seq_map_values_concat_auto<A, B>()\nensures forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}", "broken_code": "\npub proof fn seq_map_values_concat_auto<A, B>()\n f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}", "fixed_code": "\npub proof fn seq_map_values_concat_auto<A, B>()\nensures forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 96, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "seq_map_values_concat_auto", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B| #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_retransmit_un_acked_packets_for_dst_17_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n     dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "broken_code": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n     dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "fixed_code": "    pub fn retransmit_un_acked_packets_for_dst(&self, src: &EndPoint, dst: &EndPoint, packets: &mut Vec<CPacket>)\n    requires\n        self.valid(),\n        src.abstractable(),\n        outbound_packet_seq_is_valid(old(packets)@),\n        outbound_packet_seq_has_correct_srcs(old(packets)@, src@),\n        self.send_state@.contains_key(dst@),\n        Self::packets_are_valid_messages(old(packets)@),\n    ensures\n        packets@.map_values(|p: CPacket| p@).to_set() ==\n            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@),\n        outbound_packet_seq_is_valid(packets@),\n        outbound_packet_seq_has_correct_srcs(packets@, src@),\n        Self::packets_are_valid_messages(packets@),\n    {\n        proof {\n            assert_sets_equal!(\n                packets@.map_values(|p: CPacket| p@).to_set(),\n                    old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, 0 as nat),\n            );\n        }\n\n        match self.send_state.epmap.get(dst) {\n            Some(ack_state) => {\n                let mut i=0;\n\n                while i < ack_state.un_acked.len()\n                  invariant\n                    0 <= i <= ack_state.un_acked.len(),\n                    self.valid(),   // Everybody hates having to carry everything through here. :v(\n                    src.abstractable(),\n                    outbound_packet_seq_is_valid(packets@),\n                    outbound_packet_seq_has_correct_srcs(packets@, src@),\n                    self.send_state@.contains_key(dst@),\n                    ack_state == self.send_state.epmap[dst],\n                    packets@.map_values(|p: CPacket| p@).to_set() ==\n                        old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat),\n                    Self::packets_are_valid_messages(packets@),\n                  decreases\n                    ack_state.un_acked.len() - i\n                {\n                    let ghost packets0_view = packets@;\n\n                    assert( CAckState::un_acked_valid(&ack_state.un_acked@[i as int]) );    // trigger\n\n                    let sm = &ack_state.un_acked[i];\n                    let dst = match sm {\n                        CSingleMessage::Message{dst, .. } => dst,\n                        _ => { proof {assert(false); } unreached() },\n                    };\n\n                    let cpacket = CPacket{dst: dst.clone_up_to_view(), src: src.clone_up_to_view(), msg: sm.clone_up_to_view()};\n                    packets.push(cpacket);\n\n                    i = i + 1;\n\n                    proof{\n                        same_view_same_marshalable( &cpacket.msg, &sm );\n\n                        lemma_seq_push_to_set(packets0_view, cpacket);\n\n                        assert_seqs_equal!(packets@.map_values(|p: CPacket| p@),\n                                           packets0_view.map_values(|p: CPacket| p@).push(cpacket@));\n\n                        lemma_seq_push_to_set(packets0_view.map_values(|p: CPacket| p@), cpacket@);\n                        self.un_acked_messages_extend(src@, dst@, (i-1) as nat);\n\n                        assert_sets_equal!(\n                            packets@.map_values(|p: CPacket| p@).to_set(),\n                            old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest_up_to(src@, dst@, i as nat)\n                        );\n                    }\n                }\n            },\n            None => {\n                proof { assert(false); }\n            }\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 101, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "retransmit_un_acked_packets_for_dst", "mutation_type": "remove_ensures", "fix_description": "Add ensures: packets@.map_values(|p: CPacket| p@).to_set() == old(packets)@.map_values(|p: CPacket| p@).to_set() + self@.un_acked_messages_for_dest(src@, dst@), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, src@), Self::packets_are_valid_messages(packets@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_143_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "broken_code": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "fixed_code": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1101, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "mutation_type": "remove_ensures", "fix_description": "Add ensures: id@ == self@[*k], id@.valid_physical_address()", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_test_unique_26_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            \n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                \n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "broken_code": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            \n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                \n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "fixed_code": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 58, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "test_unique", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= i", "synthetic": true}}
{"id": "task_c_host_impl_v_receive_packet_next_87_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "broken_code": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "fixed_code": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 551, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "receive_packet_next", "mutation_type": "remove_ensures", "fix_description": "Add ensures: Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_host_impl_t_next_impl_1_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n         *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "broken_code": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n         *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "fixed_code": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_t.rs", "line_number": 139, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_t.rs", "function_name": "next_impl", "mutation_type": "remove_requires", "fix_description": "Add requires: Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_delegation_map_v_new_115_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn new() -> (v: Self)\n        ensures v@ == Seq::<K>::empty(),\n                v.valid(),\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn new() -> (v: Self)\n        ensures v@ == Seq::<K>::empty(),\n                v.valid(),\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }", "broken_code": "\n    fn new() -> (v: Self)\n        ensures v@ == Seq::<K>::empty(),\n                v.valid(),\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }", "fixed_code": "\n    fn new() -> (v: Self)\n        ensures v@ == Seq::<K>::empty(),\n                v.valid(),\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 126, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "mutation_type": "remove_ensures", "fix_description": "Add ensures: v@ == Seq::<K>::empty(), v.valid()", "synthetic": true}}
{"id": "task_c_delegation_map_v_sorted_subrange_152_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\nproof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    \n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "proof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    ensures\n        sorted(s.subrange(i, j)),\n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}", "broken_code": "proof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    \n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}", "fixed_code": "proof fn sorted_subrange<K: KeyTrait>(s: Seq<K>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        sorted(s),\n    ensures\n        sorted(s.subrange(i, j)),\n{\n    let sub = s.subrange(i, j);\n    assert forall |m, n| 0 <= m < n < sub.len() implies #[trigger](sub[m].cmp_spec(sub[n]).lt()) by {\n        K::cmp_properties();\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 93, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "sorted_subrange", "mutation_type": "remove_ensures", "fix_description": "Add ensures: sorted(s.subrange(i, j))", "synthetic": true}}
{"id": "task_c_delegation_map_v_insert_121_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "broken_code": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "fixed_code": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 284, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "insert", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), self@.len() == old(self)@.len() + 1, 0 <= i < self@.len(), self@ == old(self)@.insert(i as int, k), self@.to_set() == old(self)@.to_set().insert(k)", "synthetic": true}}
{"id": "task_c_host_impl_v_static_params_81_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn static_params() -> (out: Parameters)\n    \n    {\n        Parameters {\n            max_seqno: 0xffff_ffff_ffff_ffff,\n            max_delegations: 0x7FFF_FFFF_FFFF_FFFF,\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn static_params() -> (out: Parameters)\n    ensures\n        out@ == AbstractParameters::static_params(),\n    {\n        Parameters {\n            max_seqno: 0xffff_ffff_ffff_ffff,\n            max_delegations: 0x7FFF_FFFF_FFFF_FFFF,\n        }\n    }", "broken_code": "    pub fn static_params() -> (out: Parameters)\n    \n    {\n        Parameters {\n            max_seqno: 0xffff_ffff_ffff_ffff,\n            max_delegations: 0x7FFF_FFFF_FFFF_FFFF,\n        }\n    }", "fixed_code": "    pub fn static_params() -> (out: Parameters)\n    ensures\n        out@ == AbstractParameters::static_params(),\n    {\n        Parameters {\n            max_seqno: 0xffff_ffff_ffff_ffff,\n            max_delegations: 0x7FFF_FFFF_FFFF_FFFF,\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 96, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "static_params", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out@ == AbstractParameters::static_params()", "synthetic": true}}
{"id": "task_c_delegation_map_v_is_le_112_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub const fn is_le(self) -> (b:bool)\n        \n    {\n        !matches!(self, Ordering::Greater)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub const fn is_le(self) -> (b:bool)\n        ensures b == self.le(),\n    {\n        !matches!(self, Ordering::Greater)\n    }", "broken_code": "\n    pub const fn is_le(self) -> (b:bool)\n        \n    {\n        !matches!(self, Ordering::Greater)\n    }", "fixed_code": "\n    pub const fn is_le(self) -> (b:bool)\n        ensures b == self.le(),\n    {\n        !matches!(self, Ordering::Greater)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 66, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_le", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.le()", "synthetic": true}}
{"id": "task_c_io_t_send_64_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        \n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "broken_code": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        \n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "fixed_code": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/io_t.rs", "line_number": 399, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "send", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_test_unique_26_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        \n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "broken_code": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        \n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "fixed_code": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 58, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "test_unique", "mutation_type": "remove_ensures", "fix_description": "Add ensures: unique == seq_is_unique(abstractify_end_points(*endpoints))", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_receive_packet_89_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n     ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }", "broken_code": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n     ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }", "fixed_code": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 763, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_receive_packet", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_125_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        \n    {\n        self.k.as_ref().unwrap()\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }", "broken_code": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        \n    {\n        self.k.as_ref().unwrap()\n    }", "fixed_code": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 366, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "mutation_type": "remove_ensures", "fix_description": "Add ensures: k == self.get_spec()", "synthetic": true}}
{"id": "task_c_net_sht_v_receive_with_demarshal_53_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\npub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\nensures\n    ({let (rr, net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}\n```\n\nProvide the fixed code:", "target_text": "pub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\nensures\n    ({let (rr, net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}", "broken_code": "pub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\nensures\n    ({let (rr, net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}", "fixed_code": "pub fn receive_with_demarshal(netc: &mut NetClient, local_addr: &EndPoint) -> (rc: (ReceiveResult, Ghost<NetEvent>))\nrequires\n    old(netc).ok(),\n    old(netc).my_end_point() == local_addr@,\n    old(netc).state() is Receiving,\n    local_addr.abstractable(),\nensures\n    ({let (rr, net_event) = rc;\n        &&& netc.my_end_point() == old(netc).my_end_point()\n        &&& netc.ok() == !(rr is Fail)\n        &&& !(rr is Fail) ==> netc.ok() && netc.history() == old(netc).history() + seq!( net_event@ )\n        &&& rr is Timeout ==> net_event@ is TimeoutReceive\n        &&& (rr is Packet ==> {\n            &&& net_event@ is Receive\n            &&& true // NetPacketIsAbstractable is true\n            &&& rr.arrow_Packet_cpacket().abstractable() // can parse u8s up to NetEvent.\n            &&& true  // EndPointIsValidPublicKey\n            &&& !(rr.arrow_Packet_cpacket()@.msg is InvalidMessage) ==> {\n                &&& rr.arrow_Packet_cpacket()@ == abstractify_net_packet_to_sht_packet(net_event@.arrow_Receive_r())\n                &&& rr.arrow_Packet_cpacket().msg@ == sht_demarshal_data(net_event@.arrow_Receive_r().msg)@\n            }\n            &&& rr.arrow_Packet_cpacket().dst@ == local_addr@\n        })\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 169, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "receive_with_demarshal", "mutation_type": "remove_requires", "fix_description": "Add requires: old(netc).ok(), old(netc).my_end_point() == local_addr@, old(netc).state() is Receiving, local_addr.abstractable(), ensures (", "synthetic": true}}
{"id": "task_c_delegation_map_v_range_consistent_subset_146_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n         dst),\n    {\n        K::cmp_properties();\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "broken_code": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n         dst),\n    {\n        K::cmp_properties();\n    }", "fixed_code": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1368, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "range_consistent_subset", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.range_consistent(x_inner, y_inner, dst)", "synthetic": true}}
{"id": "task_c_net_sht_v_send_packet_seq_55_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "broken_code": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "fixed_code": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 353, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet_seq", "mutation_type": "remove_requires", "fix_description": "Add requires: old(netc).ok(), outbound_packet_seq_is_valid(cpackets@), outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_receive_impl_21_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }", "broken_code": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }", "fixed_code": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 343, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), rr.valid_ack(*pkt), SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()), rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@), rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@)", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_receive_packet_89_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }", "broken_code": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }", "fixed_code": "    fn host_model_receive_packet(&mut self, cpacket: CPacket) -> (rc: (Vec<CPacket>, Ghost<CPacket>))\n    requires\n        old(self).valid(),\n        old(self).host_state_packet_preconditions(cpacket),\n        !(cpacket.msg is InvalidMessage),\n        cpacket.dst@ == old(self).constants.me@,\n    ensures ({\n        let (sent_packets, ack) = rc;\n        &&& outbound_packet_seq_is_valid(sent_packets@)\n        &&& receive_packet(old(self)@, self@, cpacket@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@), ack@@)\n        // The Dafny Ironfleet \"common preconditions\" take an explicit cpacket, but we need to talk\n        // about\n        &&& self.host_state_common_postconditions(*old(self), cpacket, sent_packets@)\n        }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 763, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_receive_packet", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), old(self).host_state_packet_preconditions(cpacket), !(cpacket.msg is InvalidMessage), cpacket.dst@ == old(self).constants.me@, ensures (", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_truncate_8_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          \n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "broken_code": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          \n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "fixed_code": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 150, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "truncate", "mutation_type": "remove_invariant", "fix_description": "Add invariant: self.valid(dst)", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_map_set_singleton_auto_168_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_map_set_singleton_auto<A, B>()\n\n{\n    assert forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) =~= set![f(x)] by {\n        assert(set![x].contains(x));\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_map_set_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)],\n{\n    assert forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) =~= set![f(x)] by {\n        assert(set![x].contains(x));\n    }\n}", "broken_code": "\npub proof fn lemma_map_set_singleton_auto<A, B>()\n\n{\n    assert forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) =~= set![f(x)] by {\n        assert(set![x].contains(x));\n    }\n}", "fixed_code": "\npub proof fn lemma_map_set_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)],\n{\n    assert forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) =~= set![f(x)] by {\n        assert(set![x].contains(x));\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 288, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_map_set_singleton_auto", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)]", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_to_set_union_auto_164_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_to_set_union_auto<A>()\n     t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn lemma_to_set_union_auto<A>()\n    ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set()\n{\n    assert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}", "broken_code": "\n\npub proof fn lemma_to_set_union_auto<A>()\n     t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}", "fixed_code": "\n\npub proof fn lemma_to_set_union_auto<A>()\n    ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set()\n{\n    assert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 211, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_to_set_union_auto", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set()", "synthetic": true}}
{"id": "task_c_hashmap_t_len_41_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier::external_body]\n    pub fn len(&self) -> (l: usize)\n    \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier::external_body]\n    pub fn len(&self) -> (l: usize)\n    ensures l as int == self@.len()\n    {\n        self.m.len()\n    }", "broken_code": "\n    #[verifier::external_body]\n    pub fn len(&self) -> (l: usize)\n    ", "fixed_code": "\n    #[verifier::external_body]\n    pub fn len(&self) -> (l: usize)\n    ensures l as int == self@.len()\n    {\n        self.m.len()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 41, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "len", "mutation_type": "remove_ensures", "fix_description": "Add ensures: l as int == self@.len()", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_receive_ack_impl_19_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}", "broken_code": "    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}", "fixed_code": "    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 199, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_ack_impl", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), // self.abstractable(), pkt.abstractable(), pkt.msg is Ack, ensures self.valid(), SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!", "synthetic": true}}
{"id": "task_c_delegation_map_v_lemma_set_is_update_151_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}\n```\n\nProvide the fixed code:", "target_text": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "broken_code": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "fixed_code": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1723, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "lemma_set_is_update", "mutation_type": "remove_requires", "fix_description": "Add requires: pre.valid(), dst@.valid_physical_address(), // fn set postconditions post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()], ensures AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange", "synthetic": true}}
{"id": "task_c_host_impl_t_init_impl_0_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n    ensures\n        Self::init_ensures(netc, *args, rc),\n    {\n        Self::real_init_impl(netc, args)\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n    ensures\n        Self::init_ensures(netc, *args, rc),\n    {\n        Self::real_init_impl(netc, args)\n    }", "broken_code": "    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n    ensures\n        Self::init_ensures(netc, *args, rc),\n    {\n        Self::real_init_impl(netc, args)\n    }", "fixed_code": "    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n    ensures\n        Self::init_ensures(netc, *args, rc),\n    {\n        Self::real_init_impl(netc, args)\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_t.rs", "line_number": 105, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_t.rs", "function_name": "init_impl", "mutation_type": "remove_requires", "fix_description": "Add requires: netc.valid() // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it ensures Self::init_ensures(netc, *args, rc)", "synthetic": true}}
{"id": "task_c_delegation_map_v_greatest_lower_bound_138_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n         glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "broken_code": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n         glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "fixed_code": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 855, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.greatest_lower_bound_spec(*iter, glb)", "synthetic": true}}
{"id": "task_c_host_impl_v_empty_event_results_88_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    proof fn empty_event_results() -> (event_results: EventResults)\n    \n        event_results.ios =~= event_results.event_seq(),\n        event_results.ios == Seq::<NetEvent>::empty(),\n    {\n        EventResults{\n            recvs: Seq::<NetEvent>::empty(),\n            clocks: Seq::<NetEvent>::empty(),\n            sends: Seq::<NetEvent>::empty(),\n            ios: Seq::<NetEvent>::empty(),\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    proof fn empty_event_results() -> (event_results: EventResults)\n    ensures\n        event_results.well_typed_events(),\n        event_results.ios =~= event_results.event_seq(),\n        event_results.ios == Seq::<NetEvent>::empty(),\n    {\n        EventResults{\n            recvs: Seq::<NetEvent>::empty(),\n            clocks: Seq::<NetEvent>::empty(),\n            sends: Seq::<NetEvent>::empty(),\n            ios: Seq::<NetEvent>::empty(),\n        }\n    }", "broken_code": "    proof fn empty_event_results() -> (event_results: EventResults)\n    \n        event_results.ios =~= event_results.event_seq(),\n        event_results.ios == Seq::<NetEvent>::empty(),\n    {\n        EventResults{\n            recvs: Seq::<NetEvent>::empty(),\n            clocks: Seq::<NetEvent>::empty(),\n            sends: Seq::<NetEvent>::empty(),\n            ios: Seq::<NetEvent>::empty(),\n        }\n    }", "fixed_code": "    proof fn empty_event_results() -> (event_results: EventResults)\n    ensures\n        event_results.well_typed_events(),\n        event_results.ios =~= event_results.event_seq(),\n        event_results.ios == Seq::<NetEvent>::empty(),\n    {\n        EventResults{\n            recvs: Seq::<NetEvent>::empty(),\n            clocks: Seq::<NetEvent>::empty(),\n            sends: Seq::<NetEvent>::empty(),\n            ios: Seq::<NetEvent>::empty(),\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 637, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "empty_event_results", "mutation_type": "remove_ensures", "fix_description": "Add ensures: event_results.well_typed_events(), event_results.ios =~= event_results.event_seq(), event_results.ios == Seq::<NetEvent>::empty()", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_143_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "broken_code": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "fixed_code": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1101, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), ensures id@ == self@[*k], id@.valid_physical_address()", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_receive_impl_21_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }", "broken_code": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }", "fixed_code": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 343, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_impl", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), old(self).abstractable(), pkt.abstractable(), ensures self.valid(), rr.valid_ack(*pkt), SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()), rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@), rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@)", "synthetic": true}}
{"id": "task_c_cmessage_v_view_equal_spec_75_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n  pub proof fn view_equal_spec()\n     y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  pub proof fn view_equal_spec()\n    ensures forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@\n  {\n    assert forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "broken_code": "\n  pub proof fn view_equal_spec()\n     y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "fixed_code": "\n  pub proof fn view_equal_spec()\n    ensures forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@\n  {\n    assert forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 225, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "view_equal_spec", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@", "synthetic": true}}
{"id": "task_c_delegation_map_v_greatest_lower_bound_index_137_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }\n```\n\nProvide the fixed code:", "target_text": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "broken_code": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "fixed_code": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 760, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound_index", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), self@.contains_key(K::zero_spec()), ensures 0 <= index < self.keys@.len(), self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int]))", "synthetic": true}}
{"id": "task_c_net_sht_v_send_packet_seq_55_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\n\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "broken_code": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\n\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "fixed_code": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 353, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet_seq", "mutation_type": "remove_ensures", "fix_description": "Add ensures: netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_endpoint_hashmap_t_get_67_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n     key@) { Some(v) => Some(&v), None => None }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n    ensures\n        value == match Self::get_spec(self@, key@) { Some(v) => Some(&v), None => None }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n     key@) { Some(v) => Some(&v), None => None }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n    ensures\n        value == match Self::get_spec(self@, key@) { Some(v) => Some(&v), None => None }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/endpoint_hashmap_t.rs", "line_number": 57, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "get", "mutation_type": "remove_ensures", "fix_description": "Add ensures: value == match Self::get_spec(self@, key@)", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_receive_ack_impl_19_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}", "broken_code": "    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}", "fixed_code": "    pub fn receive_ack_impl(&mut self, pkt: &CPacket)\n    requires\n        old(self).valid(),\n       // self.abstractable(),\n        pkt.abstractable(),\n        pkt.msg is Ack,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!{}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 199, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_ack_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), SingleDelivery::receive_ack(old(self)@, self@, pkt@, set!", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_135_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        \n                Some(v) => self@[*k] == v,\n            }\n```\n\nProvide the fixed code:", "target_text": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }", "broken_code": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        \n                Some(v) => self@[*k] == v,\n            }", "fixed_code": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 673, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "mutation_type": "remove_ensures", "fix_description": "Add ensures: match o", "synthetic": true}}
{"id": "task_c_delegation_map_v_almost_all_keys_agree_149_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n         &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        let lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        let lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n\n    }", "broken_code": "\n    proof fn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n         &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        let lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n\n    }", "fixed_code": "\n    proof fn almost_all_keys_agree(&self, lo: usize, hi: usize, id: &ID)\n        requires\n            self.valid(),\n            0 <= lo <= hi < self.lows.keys@.len(),\n            forall |i| #![auto] lo <= i < hi ==> self.lows@[self.lows.keys@[i]]@ == id@,\n        ensures\n            self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id),\n        decreases hi - lo,\n    {\n        let lo_k = self.lows.keys@[lo as int];\n        let hi_k = self.lows.keys@[hi as int];\n        let lo_ki = KeyIterator::new_spec(lo_k);\n        let hi_ki = KeyIterator::new_spec(hi_k);\n        if lo_ki.geq_spec(hi_ki) {\n            self.empty_key_range_is_consistent(&lo_ki, &hi_ki, id);\n        } else {\n            assert(lo_ki.lt_spec(hi_ki) && lo < hi) by {\n                K::cmp_properties();\n            }\n            let lo_next = (lo + 1) as usize;\n            let lo_next_k = self.lows.keys@[lo_next as int];\n            let lo_next_ki = KeyIterator::new_spec(lo_next_k);\n            assert(self.lows.gap(lo_ki, lo_next_ki)) by {\n                K::cmp_properties();\n            }\n            assert(self.range_consistent(&lo_ki, &lo_next_ki, id));\n            self.almost_all_keys_agree(lo_next, hi, id);\n            self.extend_range_consistent(&lo_ki, &lo_next_ki, &hi_ki, id);\n        }\n\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1400, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "almost_all_keys_agree", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.range_consistent(&KeyIterator::new_spec(self.lows.keys@[lo as int]), &KeyIterator::new_spec(self.lows.keys@[hi as int]), id), decreases hi - lo", "synthetic": true}}
{"id": "task_c_delegation_map_v_extend_range_consistent_145_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        \n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }", "broken_code": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        \n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }", "fixed_code": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1359, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "extend_range_consistent", "mutation_type": "remove_requires", "fix_description": "Add requires: self.range_consistent(x, y, dst), self.range_consistent(y, z, dst), ensures self.range_consistent(x, z, dst)", "synthetic": true}}
{"id": "task_c_seq_lib_v_lemma_seq_add_subrange_172_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "broken_code": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "fixed_code": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/verus_extra/seq_lib_v.rs", "line_number": 15, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "lemma_seq_add_subrange", "mutation_type": "remove_requires", "fix_description": "Add requires: 0 <= i <= j <= k <= s.len(), ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k)", "synthetic": true}}
{"id": "task_c_host_impl_v_effect_of_hashmap_bulk_update_94_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn effect_of_hashmap_bulk_update(\n        pre: CKeyHashMap,\n        post: CKeyHashMap,\n        kr: &KeyRange::<CKey>,\n        other: CKeyHashMap\n    )\n        \n            valid_hashtable(other@),\n            post@ == Map::<AbstractKey, Seq<u8>>::new(\n                |k: AbstractKey| (pre@.dom().contains(k) || other@.dom().contains(k))\n                                 && (kr.contains(k) ==> other@.dom().contains(k)),\n                |k: AbstractKey| if other@.dom().contains(k) { other@[k] }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn effect_of_hashmap_bulk_update(\n        pre: CKeyHashMap,\n        post: CKeyHashMap,\n        kr: &KeyRange::<CKey>,\n        other: CKeyHashMap\n    )\n        requires\n            forall |k| pre@.dom().contains(k) ==> #[trigger] valid_value(pre@[k]),\n            valid_hashtable(other@),\n            post@ == Map::<AbstractKey, Seq<u8>>::new(\n                |k: AbstractKey| (pre@.dom().contains(k) || other@.dom().contains(k))\n                                 && (kr.contains(k) ==> other@.dom().contains(k)),\n                |k: AbstractKey| if other@.dom().contains(k) { other@[k] }", "broken_code": "\n    proof fn effect_of_hashmap_bulk_update(\n        pre: CKeyHashMap,\n        post: CKeyHashMap,\n        kr: &KeyRange::<CKey>,\n        other: CKeyHashMap\n    )\n        \n            valid_hashtable(other@),\n            post@ == Map::<AbstractKey, Seq<u8>>::new(\n                |k: AbstractKey| (pre@.dom().contains(k) || other@.dom().contains(k))\n                                 && (kr.contains(k) ==> other@.dom().contains(k)),\n                |k: AbstractKey| if other@.dom().contains(k) { other@[k] }", "fixed_code": "\n    proof fn effect_of_hashmap_bulk_update(\n        pre: CKeyHashMap,\n        post: CKeyHashMap,\n        kr: &KeyRange::<CKey>,\n        other: CKeyHashMap\n    )\n        requires\n            forall |k| pre@.dom().contains(k) ==> #[trigger] valid_value(pre@[k]),\n            valid_hashtable(other@),\n            post@ == Map::<AbstractKey, Seq<u8>>::new(\n                |k: AbstractKey| (pre@.dom().contains(k) || other@.dom().contains(k))\n                                 && (kr.contains(k) ==> other@.dom().contains(k)),\n                |k: AbstractKey| if other@.dom().contains(k) { other@[k] }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1354, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "effect_of_hashmap_bulk_update", "mutation_type": "remove_requires", "fix_description": "Add requires: forall |k| pre@.dom().contains(k) ==> #[trigger] valid_value(pre@[k]), valid_hashtable(other@), post@ == Map::<AbstractKey, Seq<u8>>::new( |k: AbstractKey| (pre@.dom().contains(k) || other@.dom().contains(k)) && (kr.contains(k) ==> other@.dom().contains(k)), |k: AbstractKey| if other@.dom().contains(k)", "synthetic": true}}
{"id": "task_c_host_impl_v_receive_packet_next_87_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n     *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "broken_code": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n     *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "fixed_code": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 551, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "receive_packet_next", "mutation_type": "remove_requires", "fix_description": "Add requires: Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_delegation_map_v_empty_key_range_is_consistent_147_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn empty_key_range_is_consistent(&self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, id: &ID)\n        requires\n            lo.geq_spec(*hi),\n        \n    {\n        K::cmp_properties();\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn empty_key_range_is_consistent(&self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, id: &ID)\n        requires\n            lo.geq_spec(*hi),\n        ensures \n            self.range_consistent(lo, hi, id),\n    {\n        K::cmp_properties();\n    }", "broken_code": "\n    proof fn empty_key_range_is_consistent(&self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, id: &ID)\n        requires\n            lo.geq_spec(*hi),\n        \n    {\n        K::cmp_properties();\n    }", "fixed_code": "\n    proof fn empty_key_range_is_consistent(&self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, id: &ID)\n        requires\n            lo.geq_spec(*hi),\n        ensures \n            self.range_consistent(lo, hi, id),\n    {\n        K::cmp_properties();\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1379, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "empty_key_range_is_consistent", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.range_consistent(lo, hi, id)", "synthetic": true}}
{"id": "task_c_hashmap_t_to_vec_47_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    #[verifier(external_body)]\n    #[verifier(when_used_as_spec(spec_to_vec))]\n    pub fn to_vec(&self) -> (res: Vec<CKeyKV>)\n       std::vec::Vec<u8>)> =\n            self.m.iter().map(|(k, v)| (k.ukey, v.clone())).collect();\n        v.sort();\n        v.into_iter()\n         .map(|(k, v)| CKeyKV { k: CKey { ukey: k }, v })\n         .collect()\n    }\n```\n\nProvide the fixed code:", "target_text": "    #[verifier(external_body)]\n    #[verifier(when_used_as_spec(spec_to_vec))]\n    pub fn to_vec(&self) -> (res: Vec<CKeyKV>)\n      ensures res == self.spec_to_vec()\n    {\n        let mut v: std::vec::Vec<(u64, std::vec::Vec<u8>)> =\n            self.m.iter().map(|(k, v)| (k.ukey, v.clone())).collect();\n        v.sort();\n        v.into_iter()\n         .map(|(k, v)| CKeyKV { k: CKey { ukey: k }, v })\n         .collect()\n    }", "broken_code": "    #[verifier(external_body)]\n    #[verifier(when_used_as_spec(spec_to_vec))]\n    pub fn to_vec(&self) -> (res: Vec<CKeyKV>)\n       std::vec::Vec<u8>)> =\n            self.m.iter().map(|(k, v)| (k.ukey, v.clone())).collect();\n        v.sort();\n        v.into_iter()\n         .map(|(k, v)| CKeyKV { k: CKey { ukey: k }, v })\n         .collect()\n    }", "fixed_code": "    #[verifier(external_body)]\n    #[verifier(when_used_as_spec(spec_to_vec))]\n    pub fn to_vec(&self) -> (res: Vec<CKeyKV>)\n      ensures res == self.spec_to_vec()\n    {\n        let mut v: std::vec::Vec<(u64, std::vec::Vec<u8>)> =\n            self.m.iter().map(|(k, v)| (k.ukey, v.clone())).collect();\n        v.sort();\n        v.into_iter()\n         .map(|(k, v)| CKeyKV { k: CKey { ukey: k }, v })\n         .collect()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 104, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "to_vec", "mutation_type": "remove_ensures", "fix_description": "Add ensures: res == self.spec_to_vec()", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_new_impl_18_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n     pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "broken_code": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n     pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "fixed_code": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 182, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "new_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: ok == SingleDelivery::new_single_message(self@, pkt@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_len_116_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn len(&self) -> (len: usize )\n        \n```\n\nProvide the fixed code:", "target_text": "\n    fn len(&self) -> (len: usize )\n        ensures len == self@.len()\n    {\n        self.v.len()\n    }", "broken_code": "\n    fn len(&self) -> (len: usize )\n        ", "fixed_code": "\n    fn len(&self) -> (len: usize )\n        ensures len == self@.len()\n    {\n        self.v.len()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 133, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "len", "mutation_type": "remove_ensures", "fix_description": "Add ensures: len == self@.len()", "synthetic": true}}
{"id": "task_c_delegation_map_v_lt_126_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn lt(&self, other: &Self) -> (b: bool)\n        \n    {\n        (!self.is_end() && other.is_end())\n            || (!self.is_end() && !other.is_end() && self.k.as_ref().unwrap().cmp(&other.k.as_ref().unwrap()).is_lt())\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn lt(&self, other: &Self) -> (b: bool)\n        ensures b == self.lt_spec(*other),\n    {\n        (!self.is_end() && other.is_end())\n            || (!self.is_end() && !other.is_end() && self.k.as_ref().unwrap().cmp(&other.k.as_ref().unwrap()).is_lt())\n    }", "broken_code": "    pub fn lt(&self, other: &Self) -> (b: bool)\n        \n    {\n        (!self.is_end() && other.is_end())\n            || (!self.is_end() && !other.is_end() && self.k.as_ref().unwrap().cmp(&other.k.as_ref().unwrap()).is_lt())\n    }", "fixed_code": "    pub fn lt(&self, other: &Self) -> (b: bool)\n        ensures b == self.lt_spec(*other),\n    {\n        (!self.is_end() && other.is_end())\n            || (!self.is_end() && !other.is_end() && self.k.as_ref().unwrap().cmp(&other.k.as_ref().unwrap()).is_lt())\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 387, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "lt", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.lt_spec(*other)", "synthetic": true}}
{"id": "task_c_delegation_map_v_to_set_114_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "broken_code": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "fixed_code": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 115, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "to_set", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), ensures s == self@.to_set(), s.finite(), s.len() == self@.len()", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_endpoints_contain_27_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            \n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "broken_code": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            \n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "fixed_code": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 104, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "endpoints_contain", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= j && j <= endpoints.len()", "synthetic": true}}
{"id": "task_c_delegation_map_v_find_key_132_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }\n```\n\nProvide the fixed code:", "target_text": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }", "broken_code": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }", "fixed_code": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 533, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "find_key", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), ensures match o", "synthetic": true}}
{"id": "task_c_keys_t_cmp_107_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }", "broken_code": "\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }", "fixed_code": "\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/keys_t.rs", "line_number": 224, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/keys_t.rs", "function_name": "cmp", "mutation_type": "remove_requires", "fix_description": "Add requires: true, // ensures o == self.cmp_spec(*other)", "synthetic": true}}
{"id": "task_c_net_sht_v_sht_demarshall_data_method_52_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\npub fn sht_demarshall_data_method(buffer: &Vec<u8>) -> (out: CSingleMessage)\n\n```\n\nProvide the fixed code:", "target_text": "pub fn sht_demarshall_data_method(buffer: &Vec<u8>) -> (out: CSingleMessage)\nensures\n    !(out is InvalidMessage) ==> {\n        &&& out.is_marshalable()\n        &&& out@ == sht_demarshal_data(buffer@)@\n        &&& out.abstractable()\n    }", "broken_code": "pub fn sht_demarshall_data_method(buffer: &Vec<u8>) -> (out: CSingleMessage)\n", "fixed_code": "pub fn sht_demarshall_data_method(buffer: &Vec<u8>) -> (out: CSingleMessage)\nensures\n    !(out is InvalidMessage) ==> {\n        &&& out.is_marshalable()\n        &&& out@ == sht_demarshal_data(buffer@)@\n        &&& out.abstractable()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 129, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "sht_demarshall_data_method", "mutation_type": "remove_ensures", "fix_description": "Add ensures: !(out is InvalidMessage) ==>", "synthetic": true}}
{"id": "task_c_delegation_map_v_find_key_132_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        \n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }\n```\n\nProvide the fixed code:", "target_text": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }", "broken_code": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        \n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }", "fixed_code": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 533, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "find_key", "mutation_type": "remove_ensures", "fix_description": "Add ensures: match o", "synthetic": true}}
{"id": "task_c_delegation_map_v_not_range_consistent_144_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n        requires\n            KeyIterator::between(*lo, *bad, *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        \n    {\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n        requires\n            KeyIterator::between(*lo, *bad, *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        ensures\n            !self.range_consistent(lo, hi, dst),\n    {\n    }", "broken_code": "\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n        requires\n            KeyIterator::between(*lo, *bad, *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        \n    {\n    }", "fixed_code": "\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n        requires\n            KeyIterator::between(*lo, *bad, *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        ensures\n            !self.range_consistent(lo, hi, dst),\n    {\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1349, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "not_range_consistent", "mutation_type": "remove_ensures", "fix_description": "Add ensures: !self.range_consistent(lo, hi, dst)", "synthetic": true}}
{"id": "task_c_delegation_map_v_vec_erase_153_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "broken_code": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "fixed_code": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 420, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "vec_erase", "mutation_type": "remove_ensures", "fix_description": "Add ensures: true, v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int)", "synthetic": true}}
{"id": "task_c_delegation_map_v_vec_erase_153_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        \n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "broken_code": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        \n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "fixed_code": "\npub fn vec_erase<A>(v: &mut Vec<A>, start: usize, end: usize)\n    requires\n        start <= end <= old(v).len(),\n    ensures\n        true,\n        v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(end as int, old(v)@.len() as int),\n{\n    let mut deleted = 0;\n    proof {\n        assert_seqs_equal!(v@,\n                           old(v)@.subrange(0, start as int) +\n                           old(v)@.subrange(start as int + deleted as int,\n                                               old(v)@.len() as int));\n    }\n    while deleted < end - start\n        invariant\n            start <= end <= old(v)@.len(),\n            v@.len() == old(v)@.len() - deleted,\n            0 <= deleted <= end - start,\n            v@ == old(v)@.subrange(0, start as int) + old(v)@.subrange(start as int + deleted as int, old(v)@.len() as int),\n        decreases\n            end - start - deleted\n    {\n        v.remove(start);\n        deleted = deleted + 1;\n        proof {\n            assert_seqs_equal!(v@,\n                               old(v)@.subrange(0, start as int) +\n                               old(v)@.subrange(start as int + deleted as int,\n                                                   old(v)@.len() as int));\n        }\n    }\n}", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 420, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "vec_erase", "mutation_type": "remove_invariant", "fix_description": "Add invariant: start <= end <= old(v)@.len()", "synthetic": true}}
{"id": "task_c_host_impl_v_make_send_only_event_results_102_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    \n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "broken_code": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    \n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "fixed_code": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 169, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "make_send_only_event_results", "mutation_type": "remove_requires", "fix_description": "Add requires: forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send ensures res@.recvs == Seq::<NetEvent>::empty(), res@.clocks == Seq::<NetEvent>::empty(), res@.sends == net_events@, res@.ios == net_events@, res@.event_seq() == net_events@, res@.well_typed_events()", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_get_11_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n     src@) { Some(v) => Some(&v), None => None }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    ensures\n        value == match HashMap::get_spec(self.epmap@, src@) { Some(v) => Some(&v), None => None }", "broken_code": "\n    pub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n     src@) { Some(v) => Some(&v), None => None }", "fixed_code": "\n    pub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    ensures\n        value == match HashMap::get_spec(self.epmap@, src@) { Some(v) => Some(&v), None => None }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 272, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "get", "mutation_type": "remove_ensures", "fix_description": "Add ensures: value == match HashMap::get_spec(self.epmap@, src@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_set_118_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "broken_code": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "fixed_code": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 147, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "set", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), i < old(self)@.len(), i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(), i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(), ensures self.valid(), self@ == old(self)@.update(i as int, k)", "synthetic": true}}
{"id": "task_c_cmessage_v_is_key_valid_79_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\npub fn is_key_valid(key: &CKey) -> (b: bool)\n    \n```\n\nProvide the fixed code:", "target_text": "pub fn is_key_valid(key: &CKey) -> (b: bool)\n    ensures b == valid_key(*key)\n{\n    true\n}", "broken_code": "pub fn is_key_valid(key: &CKey) -> (b: bool)\n    ", "fixed_code": "pub fn is_key_valid(key: &CKey) -> (b: bool)\n    ensures b == valid_key(*key)\n{\n    true\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 52, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_key_valid", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == valid_key(*key)", "synthetic": true}}
{"id": "task_c_seq_lib_v_some_differing_index_for_unequal_seqs_173_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}", "broken_code": "\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}", "fixed_code": "\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/verus_extra/seq_lib_v.rs", "line_number": 251, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "some_differing_index_for_unequal_seqs", "mutation_type": "remove_requires", "fix_description": "Add requires: s1 != s2, s1.len() == s2.len(), ensures 0 <= i < s1.len(), s1[i] != s2[i]", "synthetic": true}}
{"id": "task_c_delegation_map_v_valid_implies_complete_141_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ensures  self@.dom().is_full()\n    {\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ensures  self@.dom().is_full()\n    {\n    }", "broken_code": "\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ensures  self@.dom().is_full()\n    {\n    }", "fixed_code": "\n    pub proof fn valid_implies_complete(&self)\n        requires self.valid()\n        ensures  self@.dom().is_full()\n    {\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1067, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "valid_implies_complete", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid() ensures self@.dom().is_full()", "synthetic": true}}
{"id": "task_c_host_impl_v_should_process_received_message_impl_90_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn should_process_received_message_impl(&self) -> (b: bool)\n        requires self.num_delegations < self.constants.params.max_delegations // part of invariants()\n         dst: _dst, m: cm} => {\n                        match cm {\n                            CMessage::Delegate{..} | CMessage::Shard{..} => {\n                                // We can't just compare self.num_delegations <\n                                // self.constants.params.max_delegations - 2 because the\n                                // latter quantity might underflow. So we do the following,\n                                // which is equivalent but can't overflow or underflow because\n                                // self.num_delegations < self.constants.params.max_delegations.\n                                self.num_delegations + 1 < self.constants.params.max_delegations - 1\n                            },\n                            _ => true,\n                        }\n                    },\n                    _ => false,\n                }\n            },\n            None => false,\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn should_process_received_message_impl(&self) -> (b: bool)\n        requires self.num_delegations < self.constants.params.max_delegations // part of invariants()\n        ensures  b == should_process_received_message(self@)\n    {\n        match &self.received_packet {\n            Some(v) => {\n                match &v.msg {\n                    CSingleMessage::Message{seqno: _seqno, dst: _dst, m: cm} => {\n                        match cm {\n                            CMessage::Delegate{..} | CMessage::Shard{..} => {\n                                // We can't just compare self.num_delegations <\n                                // self.constants.params.max_delegations - 2 because the\n                                // latter quantity might underflow. So we do the following,\n                                // which is equivalent but can't overflow or underflow because\n                                // self.num_delegations < self.constants.params.max_delegations.\n                                self.num_delegations + 1 < self.constants.params.max_delegations - 1\n                            },\n                            _ => true,\n                        }\n                    },\n                    _ => false,\n                }\n            },\n            None => false,\n        }\n    }", "broken_code": "    fn should_process_received_message_impl(&self) -> (b: bool)\n        requires self.num_delegations < self.constants.params.max_delegations // part of invariants()\n         dst: _dst, m: cm} => {\n                        match cm {\n                            CMessage::Delegate{..} | CMessage::Shard{..} => {\n                                // We can't just compare self.num_delegations <\n                                // self.constants.params.max_delegations - 2 because the\n                                // latter quantity might underflow. So we do the following,\n                                // which is equivalent but can't overflow or underflow because\n                                // self.num_delegations < self.constants.params.max_delegations.\n                                self.num_delegations + 1 < self.constants.params.max_delegations - 1\n                            },\n                            _ => true,\n                        }\n                    },\n                    _ => false,\n                }\n            },\n            None => false,\n        }\n    }", "fixed_code": "    fn should_process_received_message_impl(&self) -> (b: bool)\n        requires self.num_delegations < self.constants.params.max_delegations // part of invariants()\n        ensures  b == should_process_received_message(self@)\n    {\n        match &self.received_packet {\n            Some(v) => {\n                match &v.msg {\n                    CSingleMessage::Message{seqno: _seqno, dst: _dst, m: cm} => {\n                        match cm {\n                            CMessage::Delegate{..} | CMessage::Shard{..} => {\n                                // We can't just compare self.num_delegations <\n                                // self.constants.params.max_delegations - 2 because the\n                                // latter quantity might underflow. So we do the following,\n                                // which is equivalent but can't overflow or underflow because\n                                // self.num_delegations < self.constants.params.max_delegations.\n                                self.num_delegations + 1 < self.constants.params.max_delegations - 1\n                            },\n                            _ => true,\n                        }\n                    },\n                    _ => false,\n                }\n            },\n            None => false,\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 833, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "should_process_received_message_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == should_process_received_message(self@)", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_set_request_92_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_set_request_preconditions()\n         sent_packets@)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_set_request_preconditions()\n        ensures  self.next_set_request_postconditions(*old(self), sent_packets@)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }", "broken_code": "    fn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_set_request_preconditions()\n         sent_packets@)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }", "fixed_code": "    fn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_set_request_preconditions()\n        ensures  self.next_set_request_postconditions(*old(self), sent_packets@)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1171, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_set_request", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.next_set_request_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_lemma_set_is_update_151_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n     hi}\n```\n\nProvide the fixed code:", "target_text": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "broken_code": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n     hi}", "fixed_code": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1723, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "lemma_set_is_update", "mutation_type": "remove_ensures", "fix_description": "Add ensures: AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange", "synthetic": true}}
{"id": "task_c_delegation_map_v_is_lt_110_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub const fn is_lt(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Less)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub const fn is_lt(self) -> (b:bool)\n        ensures b == self.lt(),\n    {\n        matches!(self, Ordering::Less)\n    }", "broken_code": "\n    pub const fn is_lt(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Less)\n    }", "fixed_code": "\n    pub const fn is_lt(self) -> (b:bool)\n        ensures b == self.lt(),\n    {\n        matches!(self, Ordering::Less)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 54, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_lt", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.lt()", "synthetic": true}}
{"id": "task_c_delegation_map_v_values_agree_133_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            \n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            invariant \n                lo <= i,\n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }", "broken_code": "    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            \n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }", "fixed_code": "    fn values_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@,\n            !ret.0 ==> (ret.1 == (self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)),\n    {\n        let mut i = lo;\n        while i <= hi\n            invariant \n                lo <= i,\n                self.keys@.len() <= usize::MAX,\n                hi < self.keys@.len() as usize == self.vals@.len(),\n                forall |j| #![auto] lo <= j < i ==> self.vals@[j]@ == v@,\n            decreases\n                self.keys@.len() - i\n        {\n            let eq = do_end_points_match(&self.vals[i], v);\n            if  !eq {\n                if i == hi {\n                    return (false, true);\n                } else {\n                    return (false, false);\n                }\n            } else {\n                proof {\n                    //K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        (true, true)\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 566, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "values_agree", "mutation_type": "remove_invariant", "fix_description": "Add invariant: lo <= i", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_to_set_distributes_over_addition_163_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n right);\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}", "broken_code": "\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n right);\n}", "fixed_code": "\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 193, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_to_set_distributes_over_addition", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (s+t).to_set() == s.to_set() + t.to_set()", "synthetic": true}}
{"id": "task_c_cmessage_v_clone_optional_value_78_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub fn clone_optional_value(ov: &Option::<Vec::<u8>>) -> (res: Option::<Vec::<u8>>)\n    \n        None => None,\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn clone_optional_value(ov: &Option::<Vec::<u8>>) -> (res: Option::<Vec::<u8>>)\n    ensures optional_value_view(*ov) == optional_value_view(res)\n{\n    match ov.as_ref() {\n        Some(v) => Some(clone_vec_u8(v)),\n        None => None,\n    }\n}", "broken_code": "\npub fn clone_optional_value(ov: &Option::<Vec::<u8>>) -> (res: Option::<Vec::<u8>>)\n    \n        None => None,\n    }\n}", "fixed_code": "\npub fn clone_optional_value(ov: &Option::<Vec::<u8>>) -> (res: Option::<Vec::<u8>>)\n    ensures optional_value_view(*ov) == optional_value_view(res)\n{\n    match ov.as_ref() {\n        Some(v) => Some(clone_vec_u8(v)),\n        None => None,\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 41, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_optional_value", "mutation_type": "remove_ensures", "fix_description": "Add ensures: optional_value_view(*ov) == optional_value_view(res)", "synthetic": true}}
{"id": "task_c_seq_lib_v_lemma_seq_add_subrange_172_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n   k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "broken_code": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n   k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "fixed_code": "\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/seq_lib_v.rs", "line_number": 15, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "lemma_seq_add_subrange", "mutation_type": "remove_ensures", "fix_description": "Add ensures: s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k)", "synthetic": true}}
{"id": "task_c_delegation_map_v_set_136_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "broken_code": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "fixed_code": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 689, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "set", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), self@ == old(self)@.insert(k, v), forall |lo, hi| self.gap(lo, hi) <==> old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi))", "synthetic": true}}
{"id": "task_c_hashmap_t_new_40_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        ensures out@ == Map::<AbstractKey, Seq<u8>>::empty()\n    {\n      CKeyHashMap { m: collections::HashMap::new() }\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        ensures out@ == Map::<AbstractKey, Seq<u8>>::empty()\n    {\n      CKeyHashMap { m: collections::HashMap::new() }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 34, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "new", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out@ == Map::<AbstractKey, Seq<u8>>::empty()", "synthetic": true}}
{"id": "task_c_seq_lib_v_lemma_subrange_subrange_171_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}", "broken_code": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}", "fixed_code": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/verus_extra/seq_lib_v.rs", "line_number": 4, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "lemma_subrange_subrange", "mutation_type": "remove_requires", "fix_description": "Add requires: 0 <= start <= s.len(), 0 <= midsize <= endsize <= s.len() - start, ensures s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize)", "synthetic": true}}
{"id": "task_c_delegation_map_v_greatest_lower_bound_138_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "broken_code": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "fixed_code": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 855, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), self@.contains_key(K::zero_spec()), ensures self.greatest_lower_bound_spec(*iter, glb)", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_receive_real_packet_impl_20_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn receive_real_packet_impl(&mut self, pkt: &CPacket) -> (packet_is_fresh: bool)\n    requires\n        old(self).valid(),\n        pkt.abstractable(),\n        pkt.msg is Message,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_real_packet(old(self)@, self@, pkt@),\n        packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        // We inlined NewSingleMessageImpl here.\n        let last_seqno = self.receive_state.lookup(&pkt.src);\n        match pkt.msg {\n            CSingleMessage::Message{seqno: pkt_seqno, ..} => {\n                let packet_is_fresh = pkt_seqno > 0 && pkt_seqno - 1 == last_seqno;\n                if packet_is_fresh {\n                    self.receive_state.insert(&pkt.src, last_seqno + 1);\n                }\n                packet_is_fresh \n            }\n            _ => { assert(false); unreached() }\n        }\n\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn receive_real_packet_impl(&mut self, pkt: &CPacket) -> (packet_is_fresh: bool)\n    requires\n        old(self).valid(),\n        pkt.abstractable(),\n        pkt.msg is Message,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_real_packet(old(self)@, self@, pkt@),\n        packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        // We inlined NewSingleMessageImpl here.\n        let last_seqno = self.receive_state.lookup(&pkt.src);\n        match pkt.msg {\n            CSingleMessage::Message{seqno: pkt_seqno, ..} => {\n                let packet_is_fresh = pkt_seqno > 0 && pkt_seqno - 1 == last_seqno;\n                if packet_is_fresh {\n                    self.receive_state.insert(&pkt.src, last_seqno + 1);\n                }\n                packet_is_fresh \n            }\n            _ => { assert(false); unreached() }\n        }\n\n    }", "broken_code": "    pub fn receive_real_packet_impl(&mut self, pkt: &CPacket) -> (packet_is_fresh: bool)\n    requires\n        old(self).valid(),\n        pkt.abstractable(),\n        pkt.msg is Message,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_real_packet(old(self)@, self@, pkt@),\n        packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        // We inlined NewSingleMessageImpl here.\n        let last_seqno = self.receive_state.lookup(&pkt.src);\n        match pkt.msg {\n            CSingleMessage::Message{seqno: pkt_seqno, ..} => {\n                let packet_is_fresh = pkt_seqno > 0 && pkt_seqno - 1 == last_seqno;\n                if packet_is_fresh {\n                    self.receive_state.insert(&pkt.src, last_seqno + 1);\n                }\n                packet_is_fresh \n            }\n            _ => { assert(false); unreached() }\n        }\n\n    }", "fixed_code": "    pub fn receive_real_packet_impl(&mut self, pkt: &CPacket) -> (packet_is_fresh: bool)\n    requires\n        old(self).valid(),\n        pkt.abstractable(),\n        pkt.msg is Message,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_real_packet(old(self)@, self@, pkt@),\n        packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        // We inlined NewSingleMessageImpl here.\n        let last_seqno = self.receive_state.lookup(&pkt.src);\n        match pkt.msg {\n            CSingleMessage::Message{seqno: pkt_seqno, ..} => {\n                let packet_is_fresh = pkt_seqno > 0 && pkt_seqno - 1 == last_seqno;\n                if packet_is_fresh {\n                    self.receive_state.insert(&pkt.src, last_seqno + 1);\n                }\n                packet_is_fresh \n            }\n            _ => { assert(false); unreached() }\n        }\n\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 252, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_real_packet_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), SingleDelivery::receive_real_packet(old(self)@, self@, pkt@), packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_greatest_lower_bound_index_137_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            \n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }\n```\n\nProvide the fixed code:", "target_text": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "broken_code": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            \n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "fixed_code": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 760, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound_index", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 1 <= i <= self.keys@.len()", "synthetic": true}}
{"id": "task_c_endpoint_hashmap_t_keys_70_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom()\n    {\n      self.m.keys().map(|k| k.clone_up_to_view()).collect()\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom()\n    {\n      self.m.keys().map(|k| k.clone_up_to_view()).collect()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/endpoint_hashmap_t.rs", "line_number": 114, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "keys", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out@.map_values(|e: EndPoint| e@).to_set() == self@.dom()", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_get_request_91_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n         sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n        ensures  self.next_get_request_postconditions(*old(self), sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "broken_code": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n         sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "fixed_code": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n        ensures  self.next_get_request_postconditions(*old(self), sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1068, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_get_request", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).next_get_request_preconditions() ensures self.next_get_request_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_host_impl_v_extract_range_impl_103_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\nfn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\n\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}\n```\n\nProvide the fixed code:", "target_text": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "broken_code": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\n\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "fixed_code": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 212, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "extract_range_impl", "mutation_type": "remove_requires", "fix_description": "Add requires: //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true) forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]), ensures ext@ =~= extract_range(h@, *kr)", "synthetic": true}}
{"id": "task_c_keys_t_cmp_properties_106_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn cmp_properties()\n//        ensures\n//        // Equality is eq  --- TODO: Without this we need to redefine Seq, Set, etc. operators that use ==\n//        forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(),\n//        // Reflexivity of equality\n//        forall |a:Self| #![auto] a.cmp_spec(a).eq(),\n//        // Commutativity of equality\n//        forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(),\n//        // Transitivity of equality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(),\n//        // Inequality is asymmetric\n//        forall |a:Self, b:Self|\n//            #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(),\n//        // Connected\n//        forall |a:Self, b:Self|\n//            #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(),\n//        // Transitivity of inequality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()\n    {\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn cmp_properties()\n//        ensures\n//        // Equality is eq  --- TODO: Without this we need to redefine Seq, Set, etc. operators that use ==\n//        forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(),\n//        // Reflexivity of equality\n//        forall |a:Self| #![auto] a.cmp_spec(a).eq(),\n//        // Commutativity of equality\n//        forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(),\n//        // Transitivity of equality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(),\n//        // Inequality is asymmetric\n//        forall |a:Self, b:Self|\n//            #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(),\n//        // Connected\n//        forall |a:Self, b:Self|\n//            #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(),\n//        // Transitivity of inequality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()\n    {\n    }", "broken_code": "\n    proof fn cmp_properties()\n//        ensures\n//        // Equality is eq  --- TODO: Without this we need to redefine Seq, Set, etc. operators that use ==\n//        forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(),\n//        // Reflexivity of equality\n//        forall |a:Self| #![auto] a.cmp_spec(a).eq(),\n//        // Commutativity of equality\n//        forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(),\n//        // Transitivity of equality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(),\n//        // Inequality is asymmetric\n//        forall |a:Self, b:Self|\n//            #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(),\n//        // Connected\n//        forall |a:Self, b:Self|\n//            #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(),\n//        // Transitivity of inequality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()\n    {\n    }", "fixed_code": "\n    proof fn cmp_properties()\n//        ensures\n//        // Equality is eq  --- TODO: Without this we need to redefine Seq, Set, etc. operators that use ==\n//        forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(),\n//        // Reflexivity of equality\n//        forall |a:Self| #![auto] a.cmp_spec(a).eq(),\n//        // Commutativity of equality\n//        forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(),\n//        // Transitivity of equality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(),\n//        // Inequality is asymmetric\n//        forall |a:Self, b:Self|\n//            #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(),\n//        // Connected\n//        forall |a:Self, b:Self|\n//            #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(),\n//        // Transitivity of inequality\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(),\n//        forall |a:Self, b:Self, c:Self|\n//            #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()\n    {\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/keys_t.rs", "line_number": 197, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/keys_t.rs", "function_name": "cmp_properties", "mutation_type": "remove_ensures", "fix_description": "Add ensures: // // Equality is eq --- TODO: Without this we need to redefine Seq, Set, etc. operators that use == // forall |a:Self, b:Self| #![auto] a == b <==> a.cmp_spec(b).eq(), // // Reflexivity of equality // forall |a:Self| #![auto] a.cmp_spec(a).eq(), // // Commutativity of equality // forall |a:Self, b:Self| (#[trigger] a.cmp_spec(b)).eq() == b.cmp_spec(a).eq(), // // Transitivity of equality // forall |a:Self, b:Self, c:Self| // #[trigger] a.cmp_spec(b).eq() && #[trigger] b.cmp_spec(c).eq() ==> a.cmp_spec(c).eq(), // // Inequality is asymmetric // forall |a:Self, b:Self| // #[trigger] a.cmp_spec(b).lt() <==> b.cmp_spec(a).gt(), // // Connected // forall |a:Self, b:Self| // #![auto] a.cmp_spec(b).ne() ==> a.cmp_spec(b).lt() || b.cmp_spec(a).lt(), // // Transitivity of inequality // forall |a:Self, b:Self, c:Self| // #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt(), // forall |a:Self, b:Self, c:Self| // #[trigger] a.cmp_spec(b).lt() && #[trigger] b.cmp_spec(c).le() ==> a.cmp_spec(c).lt(), // forall |a:Self, b:Self, c:Self| // #[trigger] a.cmp_spec(b).le() && #[trigger] b.cmp_spec(c).lt() ==> a.cmp_spec(c).lt()", "synthetic": true}}
{"id": "task_c_host_impl_v_make_empty_event_results_101_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub fn make_empty_event_results() -> (res: Ghost<EventResults>)\n    \n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == Seq::<NetEvent>::empty(),\n        res@.ios == Seq::<NetEvent>::empty(),\n        extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: Seq::<NetEvent>::empty(),\n        ios: Seq::<NetEvent>::empty(),\n    };\n    proof {\n        assert_sets_equal!(extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res.ios)),\n                           Set::<Packet>::empty());\n    };\n    Ghost(res)\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn make_empty_event_results() -> (res: Ghost<EventResults>)\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == Seq::<NetEvent>::empty(),\n        res@.ios == Seq::<NetEvent>::empty(),\n        extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: Seq::<NetEvent>::empty(),\n        ios: Seq::<NetEvent>::empty(),\n    };\n    proof {\n        assert_sets_equal!(extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res.ios)),\n                           Set::<Packet>::empty());\n    };\n    Ghost(res)\n}", "broken_code": "\npub fn make_empty_event_results() -> (res: Ghost<EventResults>)\n    \n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == Seq::<NetEvent>::empty(),\n        res@.ios == Seq::<NetEvent>::empty(),\n        extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: Seq::<NetEvent>::empty(),\n        ios: Seq::<NetEvent>::empty(),\n    };\n    proof {\n        assert_sets_equal!(extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res.ios)),\n                           Set::<Packet>::empty());\n    };\n    Ghost(res)\n}", "fixed_code": "\npub fn make_empty_event_results() -> (res: Ghost<EventResults>)\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == Seq::<NetEvent>::empty(),\n        res@.ios == Seq::<NetEvent>::empty(),\n        extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: Seq::<NetEvent>::empty(),\n        ios: Seq::<NetEvent>::empty(),\n    };\n    proof {\n        assert_sets_equal!(extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res.ios)),\n                           Set::<Packet>::empty());\n    };\n    Ghost(res)\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 148, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "make_empty_event_results", "mutation_type": "remove_ensures", "fix_description": "Add ensures: res@.recvs == Seq::<NetEvent>::empty(), res@.clocks == Seq::<NetEvent>::empty(), res@.sends == Seq::<NetEvent>::empty(), res@.ios == Seq::<NetEvent>::empty(), extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty()", "synthetic": true}}
{"id": "task_c_args_t_clone_vec_u8_32_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\npub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\nensures\n    out@ == v@\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n        \n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}\n```\n\nProvide the fixed code:", "target_text": "pub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\nensures\n    out@ == v@\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n        invariant\n            i <= v.len(),\n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}", "broken_code": "pub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\nensures\n    out@ == v@\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n        \n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}", "fixed_code": "pub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\nensures\n    out@ == v@\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n        invariant\n            i <= v.len(),\n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/args_t.rs", "line_number": 22, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/args_t.rs", "function_name": "clone_vec_u8", "mutation_type": "remove_invariant", "fix_description": "Add invariant: i <= v.len()", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_lookup_9_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn lookup(&self, src: &EndPoint) -> (last_seqno: u64)\n     self@),\n    {\n        match self.epmap.get(src) {\n            Some(v) => *v,\n            _ => 0,\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn lookup(&self, src: &EndPoint) -> (last_seqno: u64)\n    ensures\n        last_seqno as int == tombstone_table_lookup(src@, self@),\n    {\n        match self.epmap.get(src) {\n            Some(v) => *v,\n            _ => 0,\n        }\n    }", "broken_code": "    pub fn lookup(&self, src: &EndPoint) -> (last_seqno: u64)\n     self@),\n    {\n        match self.epmap.get(src) {\n            Some(v) => *v,\n            _ => 0,\n        }\n    }", "fixed_code": "    pub fn lookup(&self, src: &EndPoint) -> (last_seqno: u64)\n    ensures\n        last_seqno as int == tombstone_table_lookup(src@, self@),\n    {\n        match self.epmap.get(src) {\n            Some(v) => *v,\n            _ => 0,\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 212, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lookup", "mutation_type": "remove_ensures", "fix_description": "Add ensures: last_seqno as int == tombstone_table_lookup(src@, self@)", "synthetic": true}}
{"id": "task_c_delegation_map_v_remove_119_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "broken_code": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "fixed_code": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 167, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "remove", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.valid(), k == old(self)@.index(i as int), self@ == old(self)@.remove(i as int), self@.to_set() == old(self)@.to_set().remove(k)", "synthetic": true}}
{"id": "task_c_cmessage_v_view_equal_spec_71_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n  pub proof fn view_equal_spec()\n     y: &CMessage|\n      #[trigger] x.view_equal(y) <==> x@ == y@ by\n    {\n      match (x, y) {\n        (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {},\n        (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {},\n        (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {},\n        (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {},\n        (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {},\n        (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {},\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  pub proof fn view_equal_spec()\n    ensures forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@\n  {\n    assert forall |x: &CMessage, y: &CMessage|\n      #[trigger] x.view_equal(y) <==> x@ == y@ by\n    {\n      match (x, y) {\n        (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {},\n        (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {},\n        (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {},\n        (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {},\n        (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {},\n        (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {},\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "broken_code": "\n  pub proof fn view_equal_spec()\n     y: &CMessage|\n      #[trigger] x.view_equal(y) <==> x@ == y@ by\n    {\n      match (x, y) {\n        (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {},\n        (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {},\n        (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {},\n        (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {},\n        (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {},\n        (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {},\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "fixed_code": "\n  pub proof fn view_equal_spec()\n    ensures forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@\n  {\n    assert forall |x: &CMessage, y: &CMessage|\n      #[trigger] x.view_equal(y) <==> x@ == y@ by\n    {\n      match (x, y) {\n        (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {},\n        (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {},\n        (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {},\n        (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {},\n        (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {},\n        (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {},\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/cmessage_v.rs", "line_number": 85, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "view_equal_spec", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@", "synthetic": true}}
{"id": "task_c_net_sht_v_send_packet_54_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\n\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "broken_code": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\n\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "fixed_code": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 274, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet", "mutation_type": "remove_ensures", "fix_description": "Add ensures: netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_flatten_set_seq_spec_161_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    \n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures\n        (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}", "broken_code": "\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    \n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}", "fixed_code": "\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures\n        (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 111, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_flatten_set_seq_spec", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==> exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)), (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==> flatten_set_seq(sets).contains(x)) decreases sets.len()", "synthetic": true}}
{"id": "task_c_delegation_map_v_gap_means_empty_129_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "broken_code": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "fixed_code": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 495, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "gap_means_empty", "mutation_type": "remove_requires", "fix_description": "Add requires: self.gap(lo, hi), lo.lt_spec(k) && k.lt_spec(hi), self@.contains_key(*k.get()), ensures false", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_truncate_8_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "broken_code": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "fixed_code": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 150, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "truncate", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(dst), old(self).num_packets_acked <= seqno_acked, ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked", "synthetic": true}}
{"id": "task_c_io_t_clone_up_to_view_56_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn clone_up_to_view(&self) -> (res: EndPoint)\n        \n```\n\nProvide the fixed code:", "target_text": "    pub fn clone_up_to_view(&self) -> (res: EndPoint)\n        ensures res@ == self@\n    {\n        EndPoint{id: clone_vec_u8(&self.id)}\n    }", "broken_code": "    pub fn clone_up_to_view(&self) -> (res: EndPoint)\n        ", "fixed_code": "    pub fn clone_up_to_view(&self) -> (res: EndPoint)\n        ensures res@ == self@\n    {\n        EndPoint{id: clone_vec_u8(&self.id)}\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/io_t.rs", "line_number": 48, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "clone_up_to_view", "mutation_type": "remove_ensures", "fix_description": "Add ensures: res@ == self@", "synthetic": true}}
{"id": "task_c_delegation_map_v_delegate_for_key_range_is_host_impl_150_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\n    pub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n        requires\n            self.valid(),\n         KeyRange { lo: *lo, hi: *hi }\n```\n\nProvide the fixed code:", "target_text": "\n\n    pub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n        requires\n            self.valid(),\n        ensures\n            b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange { lo: *lo, hi: *hi }", "broken_code": "\n\n    pub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n        requires\n            self.valid(),\n         KeyRange { lo: *lo, hi: *hi }", "fixed_code": "\n\n    pub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n        requires\n            self.valid(),\n        ensures\n            b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange { lo: *lo, hi: *hi }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1698, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "delegate_for_key_range_is_host_impl", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange", "synthetic": true}}
{"id": "task_c_host_impl_v_host_noreceive_noclock_next_99_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }\n```\n\nProvide the fixed code:", "target_text": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "broken_code": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n     *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "fixed_code": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1720, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_noreceive_noclock_next", "mutation_type": "remove_ensures", "fix_description": "Add ensures: Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_hashmap_t_bulk_remove_46_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn bulk_remove(&mut self, kr: &KeyRange::<CKey>)\n    \n            |k: AbstractKey| old(self)@[k])\n    {\n        panic!()\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn bulk_remove(&mut self, kr: &KeyRange::<CKey>)\n    ensures\n        self@ == Map::<AbstractKey, Seq<u8>>::new(\n            |k: AbstractKey| old(self)@.dom().contains(k) && !kr.contains(k),\n            |k: AbstractKey| old(self)@[k])\n    {\n        panic!()\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn bulk_remove(&mut self, kr: &KeyRange::<CKey>)\n    \n            |k: AbstractKey| old(self)@[k])\n    {\n        panic!()\n    }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn bulk_remove(&mut self, kr: &KeyRange::<CKey>)\n    ensures\n        self@ == Map::<AbstractKey, Seq<u8>>::new(\n            |k: AbstractKey| old(self)@.dom().contains(k) && !kr.contains(k),\n            |k: AbstractKey| old(self)@[k])\n    {\n        panic!()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 91, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "bulk_remove", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@ == Map::<AbstractKey, Seq<u8>>::new( |k: AbstractKey| old(self)@.dom().contains(k) && !kr.contains(k), |k: AbstractKey| old(self)@[k])", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_map_values_singleton_auto_167_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_map_values_singleton_auto<A, B>()\n\n{\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_map_values_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],\n{\n}", "broken_code": "\npub proof fn lemma_map_values_singleton_auto<A, B>()\n\n{\n}", "fixed_code": "\npub proof fn lemma_map_values_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],\n{\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 282, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_map_values_singleton_auto", "mutation_type": "remove_ensures", "fix_description": "Add ensures: forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)]", "synthetic": true}}
{"id": "task_c_host_impl_v_deliver_outbound_packets_86_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }\n```\n\nProvide the fixed code:", "target_text": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "broken_code": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "fixed_code": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 519, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_outbound_packets", "mutation_type": "remove_requires", "fix_description": "Add requires: old(netc).ok(), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_delegation_map_v_insert_121_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "broken_code": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "fixed_code": "\n    fn insert(&mut self, k: K) -> (i: usize)\n        requires\n            old(self).valid(),\n            !old(self)@.contains(k),\n        ensures self.valid(),\n            self@.len() == old(self)@.len() + 1,\n            0 <= i < self@.len(),\n            self@ == old(self)@.insert(i as int, k),\n            self@.to_set() == old(self)@.to_set().insert(k),\n    {\n        // Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 284, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "insert", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), !old(self)@.contains(k), ensures self.valid(), self@.len() == old(self)@.len() + 1, 0 <= i < self@.len(), self@ == old(self)@.insert(i as int, k), self@.to_set() == old(self)@.to_set().insert(k)", "synthetic": true}}
{"id": "task_c_marshal_v_deserialize_39_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n  exec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      \n        res.is_marshalable(),\n        start <= mid <= end <= data@.len(),\n        data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@),\n        res@.len() == i,\n        len.ghost_serialize().len() +\n          res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start,\n        accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  exec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      invariant\n        0 <= i <= len,\n        res.is_marshalable(),\n        start <= mid <= end <= data@.len(),\n        data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@),\n        res@.len() == i,\n        len.ghost_serialize().len() +\n          res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start,\n        accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }", "broken_code": "\n  exec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      \n        res.is_marshalable(),\n        start <= mid <= end <= data@.len(),\n        data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@),\n        res@.len() == i,\n        len.ghost_serialize().len() +\n          res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start,\n        accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }", "fixed_code": "\n  exec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      invariant\n        0 <= i <= len,\n        res.is_marshalable(),\n        start <= mid <= end <= data@.len(),\n        data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@),\n        res@.len() == i,\n        len.ghost_serialize().len() +\n          res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start,\n        accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/marshal_v.rs", "line_number": 810, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "deserialize", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= i <= len", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_shard_96_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        \n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "broken_code": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        \n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "fixed_code": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1438, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_shard", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).next_shard_preconditions(), ensures self.next_shard_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_do_vec_u8s_match_24_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            \n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "broken_code": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            \n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "fixed_code": "\n    pub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        if e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 18, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "do_vec_u8s_match", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= i", "synthetic": true}}
{"id": "task_c_delegation_map_v_new_122_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn new(k: K) -> (s: Self)\n        \n```\n\nProvide the fixed code:", "target_text": "    pub fn new(k: K) -> (s: Self)\n        ensures s.k == Some(k)\n    {\n        KeyIterator { k: Some(k) }\n    }", "broken_code": "    pub fn new(k: K) -> (s: Self)\n        ", "fixed_code": "    pub fn new(k: K) -> (s: Self)\n        ensures s.k == Some(k)\n    {\n        KeyIterator { k: Some(k) }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 333, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "mutation_type": "remove_ensures", "fix_description": "Add ensures: s.k == Some(k)", "synthetic": true}}
{"id": "task_c_delegation_map_v_is_eq_108_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn is_eq(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Equal)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn is_eq(self) -> (b:bool)\n        ensures b == self.eq(),\n    {\n        matches!(self, Ordering::Equal)\n    }", "broken_code": "\n    pub fn is_eq(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Equal)\n    }", "fixed_code": "\n    pub fn is_eq(self) -> (b:bool)\n        ensures b == self.eq(),\n    {\n        matches!(self, Ordering::Equal)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 42, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_eq", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.eq()", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_insert_10_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n     last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "broken_code": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n     last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "fixed_code": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 223, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "insert", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@ =~= old(self)@.insert(src@, last_seqno as nat), self.abstractable()", "synthetic": true}}
{"id": "task_c_delegation_map_v_index_117_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    fn index(&self, i: usize) -> (k: K)\n        requires i < self@.len(),\n        ensures k == self@[i as int]\n    {\n        (self.v[i]).clone()\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn index(&self, i: usize) -> (k: K)\n        requires i < self@.len(),\n        ensures k == self@[i as int]\n    {\n        (self.v[i]).clone()\n    }", "broken_code": "    fn index(&self, i: usize) -> (k: K)\n        requires i < self@.len(),\n        ensures k == self@[i as int]\n    {\n        (self.v[i]).clone()\n    }", "fixed_code": "    fn index(&self, i: usize) -> (k: K)\n        requires i < self@.len(),\n        ensures k == self@[i as int]\n    {\n        (self.v[i]).clone()\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 141, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "index", "mutation_type": "remove_requires", "fix_description": "Add requires: i < self@.len(), ensures k == self@[i as int]", "synthetic": true}}
{"id": "task_c_hashmap_t_bulk_update_45_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn bulk_update(&mut self, kr: &KeyRange::<CKey>, other: &Self)\n        \n            |k: AbstractKey| if other@.dom().contains(k) { other@[k] }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn bulk_update(&mut self, kr: &KeyRange::<CKey>, other: &Self)\n        ensures self@ == Map::<AbstractKey, Seq<u8>>::new(\n            |k: AbstractKey| (old(self)@.dom().contains(k) || other@.dom().contains(k))\n                             && (kr.contains(k) ==> other@.dom().contains(k)),\n            |k: AbstractKey| if other@.dom().contains(k) { other@[k] }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn bulk_update(&mut self, kr: &KeyRange::<CKey>, other: &Self)\n        \n            |k: AbstractKey| if other@.dom().contains(k) { other@[k] }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn bulk_update(&mut self, kr: &KeyRange::<CKey>, other: &Self)\n        ensures self@ == Map::<AbstractKey, Seq<u8>>::new(\n            |k: AbstractKey| (old(self)@.dom().contains(k) || other@.dom().contains(k))\n                             && (kr.contains(k) ==> other@.dom().contains(k)),\n            |k: AbstractKey| if other@.dom().contains(k) { other@[k] }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 80, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "bulk_update", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@ == Map::<AbstractKey, Seq<u8>>::new( |k: AbstractKey| (old(self)@.dom().contains(k) || other@.dom().contains(k)) && (kr.contains(k) ==> other@.dom().contains(k)), |k: AbstractKey| if other@.dom().contains(k)", "synthetic": true}}
{"id": "task_c_delegation_map_v_erase_120_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            \n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }", "broken_code": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            \n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }", "fixed_code": "    fn erase(&mut self, start: usize, end: usize)\n        requires\n            old(self).valid(),\n            start <= end <= old(self)@.len(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(end as int, old(self)@.len() as int),\n            // TODO: We might want to strengthen this further to say that the two sets on the RHS\n            //       are disjoint\n            old(self)@.to_set() == self@.to_set() + old(self)@.subrange(start as int, end as int).to_set(),\n    {\n        let mut deleted = 0;\n        let ghost mut deleted_set;\n        proof {\n            deleted_set = Set::empty();\n            assert_seqs_equal!(self@,\n                               old(self)@.subrange(0, start as int) +\n                               old(self)@.subrange(start as int + deleted as int,\n                                                   old(self)@.len() as int));\n            assert_sets_equal!(deleted_set,\n                               old(self)@.subrange(start as int,\n                                                   start as int + deleted as int).to_set());\n            assert_sets_equal!(old(self)@.to_set(),\n                               self@.to_set() + deleted_set);\n        }\n        while deleted < end - start\n            invariant\n                start <= end <= old(self)@.len(),\n                self@.len() == old(self)@.len() - deleted,\n                0 <= deleted <= end - start,\n                old(self).valid(),\n                self.valid(),\n                self@ == old(self)@.subrange(0, start as int) + old(self)@.subrange(start as int + deleted as int, old(self)@.len() as int),\n                deleted_set == old(self)@.subrange(start as int, start as int + deleted as int).to_set(),\n                deleted_set.len() == deleted,\n                old(self)@.to_set() == self@.to_set() + deleted_set,\n            decreases\n                end - start - deleted,\n        {\n            let ghost mut old_deleted_set;\n            let ghost mut old_deleted_seq;\n            let ghost mut target;\n            proof {\n                old_deleted_set = deleted_set;\n                old_deleted_seq = old(self)@.subrange(start as int, start as int + deleted as int);\n                target = self@[start as int];\n                deleted_set = deleted_set.insert(self@[start as int]);\n            }\n            self.remove(start);\n            deleted = deleted + 1;\n            proof {\n                assert_seqs_equal!(self@,\n                                   old(self)@.subrange(0, start as int) +\n                                   old(self)@.subrange(start as int + deleted as int,\n                                                       old(self)@.len() as int));\n                let deleted_seq = old(self)@.subrange(start as int,\n                                                      start as int + deleted as int);\n                seq_to_set_is_finite::<K>(deleted_seq);\n                deleted_seq.unique_seq_to_set();\n\n                assert forall |e| #[trigger] deleted_set.contains(e)\n                                  implies deleted_seq.to_set().contains(e) by {\n                    if e == target {\n                        assert(deleted_seq[deleted as int - 1] == e); // OBSERVE\n                    } else {\n                        assert(old_deleted_set.contains(e));\n                        assert(old_deleted_seq.contains(e));\n                        let i = choose |i| 0 <= i < old_deleted_seq.len() && old_deleted_seq[i] == e;\n                        assert(deleted_seq[i] == e); // OBSERVE\n                    }\n                }\n                assert forall |e| #[trigger] deleted_seq.to_set().contains(e)\n                                  implies deleted_set.contains(e)  by {\n                    if e == target {\n                    } else {\n                        let i = choose |i| 0 <= i < deleted_seq.len() && deleted_seq[i] == e;\n                        assert(old_deleted_seq[i] == e);    // OBSERVE\n                    }\n                }\n                assert_sets_equal!(deleted_set,\n                                   deleted_seq.to_set());\n                assert_sets_equal!(old(self)@.to_set(),\n                                   self@.to_set() + deleted_set);\n            }\n        }\n\n    }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 197, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "erase", "mutation_type": "remove_invariant", "fix_description": "Add invariant: start <= end <= old(self)@.len()", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_singleton_seq_to_set_is_singleton_set_31_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub proof fn singleton_seq_to_set_is_singleton_set<T>(x: T)\n         set![x]);\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub proof fn singleton_seq_to_set_is_singleton_set<T>(x: T)\n        ensures seq![x].to_set() == set![x]\n    {\n        let seq1 = seq![x];\n        let set1 = seq1.to_set();\n        let set2 = set![x];\n        assert forall |y| set1.contains(y) <==> set2.contains(y) by\n        {\n            if y == x {\n                assert (seq1[0] == y);\n                assert (set1.contains(y));\n            }\n        }\n        assert_sets_equal!(seq![x].to_set(), set![x]);\n    }", "broken_code": "\n    pub proof fn singleton_seq_to_set_is_singleton_set<T>(x: T)\n         set![x]);\n    }", "fixed_code": "\n    pub proof fn singleton_seq_to_set_is_singleton_set<T>(x: T)\n        ensures seq![x].to_set() == set![x]\n    {\n        let seq1 = seq![x];\n        let set1 = seq1.to_set();\n        let set2 = set![x];\n        assert forall |y| set1.contains(y) <==> set2.contains(y) by\n        {\n            if y == x {\n                assert (seq1[0] == y);\n                assert (set1.contains(y));\n            }\n        }\n        assert_sets_equal!(seq![x].to_set(), set![x]);\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 157, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "singleton_seq_to_set_is_singleton_set", "mutation_type": "remove_ensures", "fix_description": "Add ensures: seq![x].to_set() == set![x]", "synthetic": true}}
{"id": "task_c_io_t_get_time_61_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        ensures ({\n            &&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n        }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        ", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn get_time(&mut self) -> (time: u64)\n        requires\n              old(self).state() is Receiving\n        ensures ({\n            &&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n        }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/io_t.rs", "line_number": 282, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_time", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (", "synthetic": true}}
{"id": "task_c_io_t_send_64_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "broken_code": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "fixed_code": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/io_t.rs", "line_number": 399, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "send", "mutation_type": "remove_requires", "fix_description": "Add requires: !(old(self).state() is Error) ensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_same_view_same_marshalable_23_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}\n```\n\nProvide the fixed code:", "target_text": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "broken_code": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "fixed_code": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 26, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "same_view_same_marshalable", "mutation_type": "remove_requires", "fix_description": "Add requires: x@ == y@, ensures x.is_marshalable() == y.is_marshalable()", "synthetic": true}}
{"id": "task_c_io_t_send_internal_wrapper_63_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn send_internal_wrapper(&mut self, remote: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError>)\n    \n    {\n        unsafe { self.send_internal(remote, message) }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn send_internal_wrapper(&mut self, remote: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError>)\n    ensures\n        *self == *old(self),\n    {\n        unsafe { self.send_internal(remote, message) }\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn send_internal_wrapper(&mut self, remote: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError>)\n    \n    {\n        unsafe { self.send_internal(remote, message) }\n    }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn send_internal_wrapper(&mut self, remote: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError>)\n    ensures\n        *self == *old(self),\n    {\n        unsafe { self.send_internal(remote, message) }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/io_t.rs", "line_number": 391, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "send_internal_wrapper", "mutation_type": "remove_ensures", "fix_description": "Add ensures: *self == *old(self)", "synthetic": true}}
{"id": "task_c_delegation_map_v_to_set_114_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "broken_code": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "fixed_code": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 115, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "to_set", "mutation_type": "remove_ensures", "fix_description": "Add ensures: s == self@.to_set(), s.finite(), s.len() == self@.len()", "synthetic": true}}
{"id": "task_c_host_impl_v_deliver_packet_seq_85_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }\n```\n\nProvide the fixed code:", "target_text": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "broken_code": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "fixed_code": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 433, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_packet_seq", "mutation_type": "remove_requires", "fix_description": "Add requires: old(netc).ok(), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_delegation_map_v_not_range_consistent_144_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n         *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        ensures\n            !self.range_consistent(lo, hi, dst),\n    {\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n        requires\n            KeyIterator::between(*lo, *bad, *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        ensures\n            !self.range_consistent(lo, hi, dst),\n    {\n    }", "broken_code": "\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n         *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        ensures\n            !self.range_consistent(lo, hi, dst),\n    {\n    }", "fixed_code": "\n    proof fn not_range_consistent(self, lo: &KeyIterator<K>, hi: &KeyIterator<K>, dst: &ID, bad: &KeyIterator<K>)\n        requires\n            KeyIterator::between(*lo, *bad, *hi),\n            self@.contains_key(*bad.get()),\n            self@[*bad.get()] != dst@,\n        ensures\n            !self.range_consistent(lo, hi, dst),\n    {\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1349, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "not_range_consistent", "mutation_type": "remove_requires", "fix_description": "Add requires: KeyIterator::between(*lo, *bad, *hi), self@.contains_key(*bad.get()), self@[*bad.get()] != dst@, ensures !self.range_consistent(lo, hi, dst)", "synthetic": true}}
{"id": "task_c_delegation_map_v_new_140_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "broken_code": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "fixed_code": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 1052, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "mutation_type": "remove_ensures", "fix_description": "Add ensures: s.valid(), s@ == Map::total(|k: K| id_zero@)", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_un_acked_messages_extend_15_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        requires\n            self@.send_state.contains_key(dst),\n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n         dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }\n```\n\nProvide the fixed code:", "target_text": "    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        requires\n            self@.send_state.contains_key(dst),\n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n        ensures\n            self@.un_acked_messages_for_dest_up_to(src, dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }", "broken_code": "    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        requires\n            self@.send_state.contains_key(dst),\n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n         dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }", "fixed_code": "    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        requires\n            self@.send_state.contains_key(dst),\n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n        ensures\n            self@.un_acked_messages_for_dest_up_to(src, dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 345, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "un_acked_messages_extend", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self@.un_acked_messages_for_dest_up_to(src, dst, i+1) == self@.un_acked_messages_for_dest_up_to(src, dst, i).insert( Packet", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_lemma_flatten_sets_union_157_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    \n```\n\nProvide the fixed code:", "target_text": "\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}", "broken_code": "\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ", "fixed_code": "\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 43, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_flatten_sets_union", "mutation_type": "remove_ensures", "fix_description": "Add ensures: flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_135_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }\n```\n\nProvide the fixed code:", "target_text": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }", "broken_code": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }", "fixed_code": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 673, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), ensures match o", "synthetic": true}}
{"id": "task_c_net_sht_v_sht_marshal_data_injective_51_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\nensures\n    a@ == b@,\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}\n```\n\nProvide the fixed code:", "target_text": "\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\nensures\n    a@ == b@,\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}", "broken_code": "\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\nensures\n    a@ == b@,\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}", "fixed_code": "\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\nensures\n    a@ == b@,\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 73, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "sht_marshal_data_injective", "mutation_type": "remove_requires", "fix_description": "Add requires: a.is_marshalable(), b.is_marshalable(), a.ghost_serialize() == b.ghost_serialize(), ensures a@ == b@", "synthetic": true}}
{"id": "task_c_marshal_v_serialize_35_remove_invariant", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_invariant\n```\n\nBroken code:\n```rust\n\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      \n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }\n```\n\nProvide the fixed code:", "target_text": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }", "broken_code": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      \n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }", "fixed_code": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }", "error": {"error_type": "invariant", "message": "Verification failed after remove_invariant", "file_path": "../ironsht/src/marshal_v.rs", "line_number": 321, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "serialize", "mutation_type": "remove_invariant", "fix_description": "Add invariant: 0 <= i <= self.len()", "synthetic": true}}
{"id": "task_c_delegation_map_v_remove_119_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "broken_code": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "fixed_code": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 167, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "remove", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), i < old(self)@.len(), ensures self.valid(), k == old(self)@.index(i as int), self@ == old(self)@.remove(i as int), self@.to_set() == old(self)@.to_set().remove(k)", "synthetic": true}}
{"id": "task_c_delegation_map_v_greatest_lower_bound_index_137_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n         KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }\n```\n\nProvide the fixed code:", "target_text": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "broken_code": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n         KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "fixed_code": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 760, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound_index", "mutation_type": "remove_ensures", "fix_description": "Add ensures: 0 <= index < self.keys@.len(), self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int]))", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_insert_10_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "broken_code": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "fixed_code": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 223, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "insert", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).abstractable(), src@.valid_physical_address(), ensures self@ =~= old(self)@.insert(src@, last_seqno as nat), self.abstractable()", "synthetic": true}}
{"id": "task_c_delegation_map_v_get_125_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }", "broken_code": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }", "fixed_code": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 366, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "mutation_type": "remove_requires", "fix_description": "Add requires: !self.is_end(), ensures k == self.get_spec()", "synthetic": true}}
{"id": "task_c_seq_is_unique_v_endpoints_contain_27_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        \n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "broken_code": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        \n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "fixed_code": "\n    pub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n        ensures present == abstractify_end_points(*endpoints).contains(endpoint@)\n    {\n        let mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/seq_is_unique_v.rs", "line_number": 104, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "endpoints_contain", "mutation_type": "remove_ensures", "fix_description": "Add ensures: present == abstractify_end_points(*endpoints).contains(endpoint@)", "synthetic": true}}
{"id": "task_c_host_impl_v_make_send_only_event_results_102_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    \n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}\n```\n\nProvide the fixed code:", "target_text": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "broken_code": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    \n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "fixed_code": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 169, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "make_send_only_event_results", "mutation_type": "remove_ensures", "fix_description": "Add ensures: res@.recvs == Seq::<NetEvent>::empty(), res@.clocks == Seq::<NetEvent>::empty(), res@.sends == net_events@, res@.ios == net_events@, res@.event_seq() == net_events@, res@.well_typed_events()", "synthetic": true}}
{"id": "task_c_io_t_receive_62_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        \n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        \n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/io_t.rs", "line_number": 335, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "receive", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.my_end_point() == old(self).my_end_point(), match result", "synthetic": true}}
{"id": "task_c_delegation_map_v_is_gt_111_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub const fn is_gt(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Greater)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub const fn is_gt(self) -> (b:bool)\n        ensures b == self.gt(),\n    {\n        matches!(self, Ordering::Greater)\n    }", "broken_code": "\n    pub const fn is_gt(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Greater)\n    }", "fixed_code": "\n    pub const fn is_gt(self) -> (b:bool)\n        ensures b == self.gt(),\n    {\n        matches!(self, Ordering::Greater)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 60, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_gt", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.gt()", "synthetic": true}}
{"id": "task_c_delegation_map_v_is_ge_113_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub const fn is_ge(self) -> (b:bool)\n        \n    {\n        !matches!(self, Ordering::Less)\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    pub const fn is_ge(self) -> (b:bool)\n        ensures b == self.ge(),\n    {\n        !matches!(self, Ordering::Less)\n    }", "broken_code": "\n    pub const fn is_ge(self) -> (b:bool)\n        \n    {\n        !matches!(self, Ordering::Less)\n    }", "fixed_code": "\n    pub const fn is_ge(self) -> (b:bool)\n        ensures b == self.ge(),\n    {\n        !matches!(self, Ordering::Less)\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 72, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_ge", "mutation_type": "remove_ensures", "fix_description": "Add ensures: b == self.ge()", "synthetic": true}}
{"id": "task_c_net_sht_v_sht_marshal_data_injective_51_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\n\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}\n```\n\nProvide the fixed code:", "target_text": "\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\nensures\n    a@ == b@,\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}", "broken_code": "\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\n\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}", "fixed_code": "\n#[verifier(spinoff_prover)]\npub proof fn sht_marshal_data_injective(a: &CSingleMessage, b: &CSingleMessage)\nrequires\n    a.is_marshalable(),\n    b.is_marshalable(),\n    a.ghost_serialize() == b.ghost_serialize(),\nensures\n    a@ == b@,\n{\n    a.lemma_serialize_injective(b);\n    assert(a@ == b@); // OBSERVE; although not entirely sure why this is necessary here, esp since it exactly matches the postcondition.\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/net_sht_v.rs", "line_number": 73, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "sht_marshal_data_injective", "mutation_type": "remove_ensures", "fix_description": "Add ensures: a@ == b@", "synthetic": true}}
{"id": "task_c_host_impl_v_host_noreceive_noclock_next_99_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n     *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }\n```\n\nProvide the fixed code:", "target_text": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "broken_code": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n     *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "fixed_code": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1720, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_noreceive_noclock_next", "mutation_type": "remove_requires", "fix_description": "Add requires: Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc)", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_cack_state_swap_12_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "broken_code": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "fixed_code": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 283, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "cack_state_swap", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).valid(), src.abstractable(), ensures HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default)", "synthetic": true}}
{"id": "task_c_endpoint_hashmap_t_new_65_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn new() -> (out: Self)\n         V>::empty()\n    {\n      HashMap { m: collections::HashMap::new() }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: Self)\n        ensures out@ == Map::<AbstractEndPoint, V>::empty()\n    {\n      HashMap { m: collections::HashMap::new() }\n    }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: Self)\n         V>::empty()\n    {\n      HashMap { m: collections::HashMap::new() }\n    }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: Self)\n        ensures out@ == Map::<AbstractEndPoint, V>::empty()\n    {\n      HashMap { m: collections::HashMap::new() }\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/endpoint_hashmap_t.rs", "line_number": 26, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "new", "mutation_type": "remove_ensures", "fix_description": "Add ensures: out@ == Map::<AbstractEndPoint, V>::empty()", "synthetic": true}}
{"id": "task_c_single_delivery_model_v_new_impl_18_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "broken_code": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "fixed_code": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_model_v.rs", "line_number": 182, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "new_impl", "mutation_type": "remove_requires", "fix_description": "Add requires: self.valid(), self.abstractable(), pkt.abstractable(), ensures ok == SingleDelivery::new_single_message(self@, pkt@)", "synthetic": true}}
{"id": "task_c_host_impl_v_host_model_next_shard_96_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n         sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }\n```\n\nProvide the fixed code:", "target_text": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "broken_code": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n         sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "fixed_code": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 1438, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_shard", "mutation_type": "remove_ensures", "fix_description": "Add ensures: self.next_shard_postconditions(*old(self), sent_packets@)", "synthetic": true}}
{"id": "task_c_host_impl_v_deliver_packet_seq_85_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        \n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }\n```\n\nProvide the fixed code:", "target_text": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "broken_code": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        \n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "fixed_code": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/host_impl_v.rs", "line_number": 433, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_packet_seq", "mutation_type": "remove_ensures", "fix_description": "Add ensures: netc.my_end_point() == old(netc).my_end_point(), (", "synthetic": true}}
{"id": "task_c_delegation_map_v_gap_means_empty_129_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        \n    {\n        self.mind_the_gap();\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "broken_code": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        \n    {\n        self.mind_the_gap();\n    }", "fixed_code": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/delegation_map_v.rs", "line_number": 495, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "gap_means_empty", "mutation_type": "remove_ensures", "fix_description": "Add ensures: false", "synthetic": true}}
{"id": "task_c_single_delivery_state_v_abstractify_distributes_over_skip_7_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }\n```\n\nProvide the fixed code:", "target_text": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }", "broken_code": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }", "fixed_code": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/single_delivery_state_v.rs", "line_number": 138, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "abstractify_distributes_over_skip", "mutation_type": "remove_requires", "fix_description": "Add requires: 0 <= i <= cm.len(), ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i", "synthetic": true}}
{"id": "task_c_hashmap_t_get_44_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn get(&self, key: &CKey) -> (value: Option<&Vec<u8>>)\n      \n        None => !self@.dom().contains(*key),\n      }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn get(&self, key: &CKey) -> (value: Option<&Vec<u8>>)\n      ensures (match value {\n        Some(v) => self@.dom().contains(*key) && self@[*key] == v@,\n        None => !self@.dom().contains(*key),\n      }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn get(&self, key: &CKey) -> (value: Option<&Vec<u8>>)\n      \n        None => !self@.dom().contains(*key),\n      }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn get(&self, key: &CKey) -> (value: Option<&Vec<u8>>)\n      ensures (match value {\n        Some(v) => self@.dom().contains(*key) && self@[*key] == v@,\n        None => !self@.dom().contains(*key),\n      }", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/hashmap_t.rs", "line_number": 65, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "get", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (match value", "synthetic": true}}
{"id": "task_c_set_lib_ext_v_flatten_sets_spec_155_remove_ensures", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    \n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}\n```\n\nProvide the fixed code:", "target_text": "\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    ensures\n        (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}", "broken_code": "\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    \n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}", "fixed_code": "\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    ensures\n        (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}", "error": {"error_type": "postcondition", "message": "Verification failed after remove_ensures", "file_path": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "line_number": 30, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "flatten_sets_spec", "mutation_type": "remove_ensures", "fix_description": "Add ensures: (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)), (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))", "synthetic": true}}
{"id": "task_c_io_t_get_time_internal_60_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        \n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        requires\n            from_trusted_code()\n    {\n        (self.c_pointers.get_time_func)()\n    }", "broken_code": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        ", "fixed_code": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        requires\n            from_trusted_code()\n    {\n        (self.c_pointers.get_time_func)()\n    }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/io_t.rs", "line_number": 274, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_time_internal", "mutation_type": "remove_requires", "fix_description": "Add requires: from_trusted_code()", "synthetic": true}}
{"id": "task_c_io_t_receive_62_remove_requires", "task": "error_repair", "input_text": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        \n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n```\n\nProvide the fixed code:", "target_text": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "broken_code": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        \n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "fixed_code": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "error": {"error_type": "precondition", "message": "Verification failed after remove_requires", "file_path": "../ironsht/src/io_t.rs", "line_number": 335, "column": 0, "context": "", "suggestion": null}, "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "receive", "mutation_type": "remove_requires", "fix_description": "Add requires: old(self).state() is Receiving ensures self.my_end_point() == old(self).my_end_point(), match result", "synthetic": true}}
