{"id": "task_a_delegation_map_v_gap_means_empty_129", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n```\n\nWrite the specifications:", "target_text": "requires self.gap(lo, hi), lo.lt_spec(k) && k.lt_spec(hi), self@.contains_key(*k.get()),\nensures false,", "full_function": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "gap_means_empty", "function_mode": "proof", "line_start": 495, "line_end": 505, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_io_t_get_my_end_point_59", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get_my_end_point(&self) -> (ep: EndPoint)\n```\n\nWrite the specifications:", "target_text": "ensures ep@ == self.my_end_point(),", "full_function": "\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        ensures\n            ep@ == self.my_end_point()\n    {\n        self.end_point.clone_up_to_view()\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_my_end_point", "function_mode": "exec", "line_start": 267, "line_end": 273, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_net_sht_v_send_packet_seq_55", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\n```\n\nWrite the specifications:", "target_text": "requires old(netc).ok(), outbound_packet_seq_is_valid(cpackets@), outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures netc.my_end_point() == old(netc).my_end_point(), (,", "full_function": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet_seq", "function_mode": "exec", "line_start": 353, "line_end": 369, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_model_v_same_view_same_marshalable_23", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\n```\n\nWrite the specifications:", "target_text": "requires x@ == y@,\nensures x.is_marshalable() == y.is_marshalable(),", "full_function": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "same_view_same_marshalable", "function_mode": "proof", "line_start": 26, "line_end": 37, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 5, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_state_v_abstractify_distributes_over_skip_7", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n```\n\nWrite the specifications:", "target_text": "requires 0 <= i <= cm.len(),\nensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\ndecreases i,", "full_function": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "abstractify_distributes_over_skip", "function_mode": "proof", "line_start": 138, "line_end": 149, "has_loop_invariant": false, "has_decreases": true, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_single_delivery_state_v_truncate_8", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(dst), old(self).num_packets_acked <= seqno_acked,\nensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\ninvariant self.valid(dst), self == old(self), i <= self.un_acked.len(), i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1, forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked, Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst), truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.num_packets_acked + i <= seqno_acked,", "full_function": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "truncate", "function_mode": "exec", "line_start": 150, "line_end": 194, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 16, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_delegation_map_v_is_eq_108", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_eq(self) -> (b:bool)\n```\n\nWrite the specifications:", "target_text": "ensures b == self.eq(),", "full_function": "\n    pub fn is_eq(self) -> (b:bool)\n        ensures b == self.eq(),\n    {\n        matches!(self, Ordering::Equal)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_eq", "function_mode": "exec", "line_start": 42, "line_end": 47, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_delegation_map_v_lemma_set_is_update_151", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n```\n\nWrite the specifications:", "target_text": "requires pre.valid(), dst@.valid_physical_address(), // fn set postconditions post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\nensures AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange,", "full_function": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "lemma_set_is_update", "function_mode": "proof", "line_start": 1723, "line_end": 1734, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<CKey>"}}
{"id": "task_a_single_delivery_model_v_send_single_cmessage_22", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), old(self).abstractable(), m.abstractable(), m.message_marshallable(), m.is_marshalable(), dst@.valid_physical_address(),\nensures self.valid(), match sm { Some(sm) => { &&& sm.abstractable() &&& sm is Message &&& sm.arrow_Message_dst()@ == dst@ &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params()) &&& sm.is_marshalable() }, None => SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()), }, // TODO: capture the part of send_single_message when should_send == false,", "full_function": "    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            },\n            // TODO: capture the part of send_single_message when should_send == false\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "send_single_cmessage", "function_mode": "exec", "line_start": 393, "line_end": 525, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 38, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_delegation_map_v_erase_139", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn erase(&mut self, lo: &KeyIterator<K>, hi: &KeyIterator<K>)\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(),\nensures self.valid(), forall |k|,", "full_function": "    fn erase(&mut self, lo: &KeyIterator<K>, hi: &KeyIterator<K>)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            forall |k| {\n                let ki = KeyIterator::new_spec(k);\n                (if ki.geq_spec(*lo) && ki.lt_spec(*hi) {\n                    !(#[trigger] self@.contains_key(k))\n                } else {\n                    (old(self)@.contains_key(k) ==>\n                         self@.contains_key(k) && self@[k] == old(self)@[k])\n                    && (self@.contains_key(k) ==> old(self)@.contains_key(k))\n                })}", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "erase", "function_mode": "exec", "line_start": 868, "line_end": 881, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_seq_is_unique_v_test_unique_26", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n```\n\nWrite the specifications:", "target_text": "ensures unique == seq_is_unique(abstractify_end_points(*endpoints)),\ninvariant 0 <= i, i <= endpoints.len(), forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@] 0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\ninvariant 0 <= i, i < endpoints.len(), forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@] 0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@, 0 <= j, j <= endpoints.len(), forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,", "full_function": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "test_unique", "function_mode": "exec", "line_start": 58, "line_end": 103, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 13, "is_method": false, "impl_type": null}}
{"id": "task_a_marshal_v_serialize_35", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nexec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }\n```\n\nWrite the specifications:", "target_text": "invariant 0 <= i <= self.len(), self.is_marshalable(), self.ghost_serialize().len() == init@ + self.len(), 0 <= i + init@ <= self.ghost_serialize().len(), data@.subrange(0, old(data)@.len() as int) == old(data)@, data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@), data@.len() == old(data)@.len() + i + init@,", "full_function": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }", "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "serialize", "function_mode": "exec", "line_start": 321, "line_end": 366, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 0, "complexity_score": 28, "is_method": false, "impl_type": null}}
{"id": "task_a_io_t_valid_physical_address_57", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn valid_physical_address(&self) -> (out: bool)\n```\n\nWrite the specifications:", "target_text": "ensures out == self@.valid_physical_address(),", "full_function": "    pub fn valid_physical_address(&self) -> (out: bool)\n    ensures\n        out == self@.valid_physical_address(),\n    {\n        self.id.len() < 0x100000\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "valid_physical_address", "function_mode": "exec", "line_start": 70, "line_end": 75, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "EndPoint"}}
{"id": "task_a_io_t_receive_62", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n```\n\nWrite the specifications:", "target_text": "requires old(self).state() is Receiving,\nensures self.my_end_point() == old(self).my_end_point(), match result { NetcReceiveResult::Received{sender, message} => { &&& self.state() is Receiving &&& sender.abstractable() &&& self.history() == old(self).history() + seq![ LIoOp::Receive{ r: LPacket{ dst: self.my_end_point(), src: sender@, msg: message@} }] } NetcReceiveResult::TimedOut{} => { &&& self.state() is Sending &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}] } NetcReceiveResult::Error{} => { self.state() is Error } },", "full_function": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n    {\n        let result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "receive", "function_mode": "exec", "line_start": 335, "line_end": 376, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 10, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_endpoint_hashmap_t_keys_70", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n```\n\nWrite the specifications:", "target_text": "ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom(),", "full_function": "\n    #[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom()\n    {\n      self.m.keys().map(|k| k.clone_up_to_view()).collect()\n    }", "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "keys", "function_mode": "exec", "line_start": 114, "line_end": 120, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "HashMap<V>"}}
{"id": "task_a_single_delivery_state_v_lemma_seqno_in_un_acked_list_6", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n```\n\nWrite the specifications:", "target_text": "requires self.valid(dst), 0 <= k < self.un_acked@.len(),\nensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1,\ndecreases k,", "full_function": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lemma_seqno_in_un_acked_list", "function_mode": "proof", "line_start": 124, "line_end": 137, "has_loop_invariant": false, "has_decreases": true, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_seq_is_unique_v_clone_option_vec_u8_28", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n```\n\nWrite the specifications:", "target_text": "ensures match ov { Some(e1) => res.is_some() && e1@ == res->0@, None => res is None, },", "full_function": "\n    pub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n        ensures\n            match ov {\n                Some(e1) => res.is_some() && e1@ == res->0@,\n                None => res is None,\n            }\n    {\n        match ov {\n            Some(e1) => Some(clone_vec_u8(e1)),\n            None => None,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_option_vec_u8", "function_mode": "exec", "line_start": 124, "line_end": 136, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_set_lib_ext_v_lemma_to_set_union_auto_163", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_to_set_union_auto<A>()\n```\n\nWrite the specifications:", "target_text": "ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set(),", "full_function": "\n\npub proof fn lemma_to_set_union_auto<A>()\n    ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set()\n{\n    assert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_to_set_union_auto", "function_mode": "proof", "line_start": 211, "line_end": 219, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 3, "is_method": false, "impl_type": null}}
