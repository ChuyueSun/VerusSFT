{"id": "task_a_delegation_map_v_gap_means_empty_129", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        \n    {\n        self.mind_the_gap();\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.gap(lo, hi), lo.lt_spec(k) && k.lt_spec(hi), self@.contains_key(*k.get()), ensures false,\nensures false,", "full_function": "\n    proof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n        requires\n            self.gap(lo, hi),\n            lo.lt_spec(k) && k.lt_spec(hi),\n            self@.contains_key(*k.get()),\n        ensures\n            false,\n    {\n        self.mind_the_gap();\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "gap_means_empty", "function_mode": "proof", "line_start": 495, "line_end": 505, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_io_t_get_my_end_point_59", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get_my_end_point(&self) -> (ep: EndPoint)\n        {\n        self.end_point.clone_up_to_view()\n    }\n```\n\nWrite the specifications:", "target_text": "ensures ep@ == self.my_end_point(),", "full_function": "\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        ensures\n            ep@ == self.my_end_point()\n    {\n        self.end_point.clone_up_to_view()\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_my_end_point", "function_mode": "exec", "line_start": 267, "line_end": 273, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_net_sht_v_send_packet_seq_55", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(netc).ok(), outbound_packet_seq_is_valid(cpackets@), outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (,\nensures netc.my_end_point() == old(netc).my_end_point(), (,", "full_function": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet_seq", "function_mode": "exec", "line_start": 353, "line_end": 369, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_model_v_same_view_same_marshalable_23", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\n\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}\n```\n\nWrite the specifications:", "target_text": "requires x@ == y@, ensures x.is_marshalable() == y.is_marshalable(),\nensures x.is_marshalable() == y.is_marshalable(),", "full_function": "\n\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\nrequires\n    x@ == y@,\nensures\n    x.is_marshalable() == y.is_marshalable(),\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "same_view_same_marshalable", "function_mode": "proof", "line_start": 26, "line_end": 37, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 5, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_state_v_abstractify_distributes_over_skip_7", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    \n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires 0 <= i <= cm.len(), ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i,\nensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i,\ndecreases i,", "full_function": "\n    proof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires\n        0 <= i <= cm.len(),\n    ensures\n        abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\n    decreases i\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "abstractify_distributes_over_skip", "function_mode": "proof", "line_start": 138, "line_end": 149, "has_loop_invariant": false, "has_decreases": true, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_single_delivery_state_v_truncate_8", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          \n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(dst), old(self).num_packets_acked <= seqno_acked, ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\nensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\ninvariant self.valid(dst),", "full_function": "\n    pub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    requires\n        old(self).valid(dst),\n        old(self).num_packets_acked <= seqno_acked,\n    ensures\n        self.valid(dst),\n        abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n        self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1,\n        self.num_packets_acked == seqno_acked,\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "truncate", "function_mode": "exec", "line_start": 150, "line_end": 194, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 16, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_delegation_map_v_is_eq_108", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_eq(self) -> (b:bool)\n        \n    {\n        matches!(self, Ordering::Equal)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.eq(),", "full_function": "\n    pub fn is_eq(self) -> (b:bool)\n        ensures b == self.eq(),\n    {\n        matches!(self, Ordering::Equal)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_eq", "function_mode": "exec", "line_start": 42, "line_end": 47, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_delegation_map_v_lemma_set_is_update_151", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    {lo, hi}\n```\n\nWrite the specifications:", "target_text": "requires pre.valid(), dst@.valid_physical_address(), // fn set postconditions post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()], ensures AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange,\nensures AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange,", "full_function": "\n\n    pub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n    requires\n        pre.valid(),\n        dst@.valid_physical_address(),\n        // fn set postconditions\n        post.valid(),\n        forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@,\n        forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures\n        AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange{lo, hi}", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "lemma_set_is_update", "function_mode": "proof", "line_start": 1723, "line_end": 1734, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<CKey>"}}
{"id": "task_a_single_delivery_model_v_send_single_cmessage_22", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), old(self).abstractable(), m.abstractable(), m.message_marshallable(), m.is_marshalable(), dst@.valid_physical_address(), ensures self.valid(), match sm,\nensures self.valid(), match sm,", "full_function": "    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            }", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "send_single_cmessage", "function_mode": "exec", "line_start": 393, "line_end": 414, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_delegation_map_v_erase_139", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn erase(&mut self, lo: &KeyIterator<K>, hi: &KeyIterator<K>)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            forall |k| {\n                let ki = KeyIterator::new_spec(k);\n                (if ki.geq_spec(*lo) && ki.lt_spec(*hi) {\n                    !(#[trigger] self@.contains_key(k))\n                } else {\n                    (old(self)@.contains_key(k) ==>\n                         self@.contains_key(k) && self@[k] == old(self)@[k])\n                    && (self@.contains_key(k) ==> old(self)@.contains_key(k))\n                })}\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), ensures self.valid(), forall |k|,\nensures self.valid(), forall |k|,", "full_function": "    fn erase(&mut self, lo: &KeyIterator<K>, hi: &KeyIterator<K>)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            forall |k| {\n                let ki = KeyIterator::new_spec(k);\n                (if ki.geq_spec(*lo) && ki.lt_spec(*hi) {\n                    !(#[trigger] self@.contains_key(k))\n                } else {\n                    (old(self)@.contains_key(k) ==>\n                         self@.contains_key(k) && self@[k] == old(self)@[k])\n                    && (self@.contains_key(k) ==> old(self)@.contains_key(k))\n                })}", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "erase", "function_mode": "exec", "line_start": 868, "line_end": 881, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_seq_is_unique_v_test_unique_26", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        \n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            \n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                \n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }\n```\n\nWrite the specifications:", "target_text": "ensures unique == seq_is_unique(abstractify_end_points(*endpoints)),\ninvariant 0 <= i,\ninvariant 0 <= i,", "full_function": "    pub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n        ensures\n            unique == seq_is_unique(abstractify_end_points(*endpoints)),\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "test_unique", "function_mode": "exec", "line_start": 58, "line_end": 103, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 13, "is_method": false, "impl_type": null}}
{"id": "task_a_marshal_v_serialize_35", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nexec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      \n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }\n```\n\nWrite the specifications:", "target_text": "invariant 0 <= i <= self.len(),", "full_function": "\n  exec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }", "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "serialize", "function_mode": "exec", "line_start": 321, "line_end": 366, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 0, "complexity_score": 28, "is_method": false, "impl_type": null}}
{"id": "task_a_io_t_valid_physical_address_57", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn valid_physical_address(&self) -> (out: bool)\n    \n    {\n        self.id.len() < 0x100000\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out == self@.valid_physical_address(),", "full_function": "    pub fn valid_physical_address(&self) -> (out: bool)\n    ensures\n        out == self@.valid_physical_address(),\n    {\n        self.id.len() < 0x100000\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "valid_physical_address", "function_mode": "exec", "line_start": 70, "line_end": 75, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "EndPoint"}}
{"id": "task_a_io_t_receive_62", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n```\n\nWrite the specifications:", "target_text": "requires old(self).state() is Receiving ensures self.my_end_point() == old(self).my_end_point(), match result,\nensures self.my_end_point() == old(self).my_end_point(), match result,", "full_function": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "receive", "function_mode": "exec", "line_start": 335, "line_end": 361, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_endpoint_hashmap_t_keys_70", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      {\n      self.m.keys().map(|k| k.clone_up_to_view()).collect()\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom(),", "full_function": "\n    #[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n      ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom()\n    {\n      self.m.keys().map(|k| k.clone_up_to_view()).collect()\n    }", "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "keys", "function_mode": "exec", "line_start": 114, "line_end": 120, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "HashMap<V>"}}
{"id": "task_a_single_delivery_state_v_lemma_seqno_in_un_acked_list_6", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.valid(dst), 0 <= k < self.un_acked@.len(), ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k,\nensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k,\ndecreases k,", "full_function": "\n    pub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n        requires\n            self.valid(dst),\n            0 <= k < self.un_acked@.len(),\n        ensures\n            self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1\n        decreases\n            k\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lemma_seqno_in_un_acked_list", "function_mode": "proof", "line_start": 124, "line_end": 137, "has_loop_invariant": false, "has_decreases": true, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_seq_is_unique_v_clone_option_vec_u8_28", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n        {\n                Some(e1) => res.is_some() && e1@ == res->0@,\n                None => res is None,\n            }\n```\n\nWrite the specifications:", "target_text": "ensures match ov,", "full_function": "\n    pub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n        ensures\n            match ov {\n                Some(e1) => res.is_some() && e1@ == res->0@,\n                None => res is None,\n            }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_option_vec_u8", "function_mode": "exec", "line_start": 124, "line_end": 130, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_set_lib_ext_v_lemma_to_set_distributes_over_addition_163", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}\n```\n\nWrite the specifications:", "target_text": "ensures (s+t).to_set() == s.to_set() + t.to_set(),", "full_function": "\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_to_set_distributes_over_addition", "function_mode": "proof", "line_start": 193, "line_end": 210, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 7, "is_method": false, "impl_type": null}}
