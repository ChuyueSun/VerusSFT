{"id": "task_a_host_impl_v_deliver_outbound_packets_86", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n```\n\nWrite the specifications:", "target_text": "requires old(netc).ok(), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\nensures netc.my_end_point() == old(netc).my_end_point(), (,", "full_function": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_outbound_packets", "function_mode": "exec", "line_start": 519, "line_end": 545, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 8, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_set_lib_ext_v_lemma_flatten_sets_union_auto_157", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_flatten_sets_union_auto<A>()\n```\n\nWrite the specifications:", "target_text": "ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>| #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),", "full_function": "\npub proof fn lemma_flatten_sets_union_auto<A>()\n    ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)) by {\n        lemma_flatten_sets_union(sets1, sets2);\n    }\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_flatten_sets_union_auto", "function_mode": "proof", "line_start": 50, "line_end": 59, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 3, "is_method": false, "impl_type": null}}
{"id": "task_a_marshal_v_deserialize_39", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nexec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }\n```\n\nWrite the specifications:", "target_text": "invariant 0 <= i <= len, res.is_marshalable(), start <= mid <= end <= data@.len(), data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@), res@.len() == i, len.ghost_serialize().len() + res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start, accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),", "full_function": "\n  exec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      invariant\n        0 <= i <= len,\n        res.is_marshalable(),\n        start <= mid <= end <= data@.len(),\n        data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@),\n        res@.len() == i,\n        len.ghost_serialize().len() +\n          res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start,\n        accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }", "metadata": {"source_file": "../ironsht/src/marshal_v.rs", "function_name": "deserialize", "function_mode": "exec", "line_start": 810, "line_end": 894, "has_loop_invariant": true, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 0, "complexity_score": 33, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_range_consistent_subset_146", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID)\n```\n\nWrite the specifications:", "target_text": "requires self.range_consistent(x, y, dst), x_inner.geq_spec(*x), !y.lt_spec(*y_inner),\nensures self.range_consistent(x_inner, y_inner, dst),", "full_function": "\n    proof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            x_inner.geq_spec(*x),\n            !y.lt_spec(*y_inner),\n        ensures\n            self.range_consistent(x_inner, y_inner, dst),\n    {\n        K::cmp_properties();\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "range_consistent_subset", "function_mode": "proof", "line_start": 1368, "line_end": 1378, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<K>"}}
{"id": "task_a_host_impl_v_receive_packet_next_87", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires(*old(self), *old(netc)),\n    ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),", "full_function": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "receive_packet_next", "function_mode": "exec", "line_start": 551, "line_end": 622, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 51, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_set_lib_ext_v_lemma_seq_push_to_set_161", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n```\n\nWrite the specifications:", "target_text": "ensures s.push(x).to_set() == s.to_set().insert(x),", "full_function": "\n\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n    ensures s.push(x).to_set() == s.to_set().insert(x)\n{\n    assert_sets_equal!(s.push(x).to_set() == s.to_set().insert(x), elem => {\n        if elem == x {\n            assert(s.push(x)[s.len() as int] == x);\n            assert(s.push(x).contains(x))\n        } else {\n            if s.to_set().insert(x).contains(elem) {\n                assert(s.to_set().contains(elem));\n                let i = choose |i: int| 0 <= i < s.len() && s[i] == elem;\n                assert(s.push(x)[i] == elem);\n            }\n        }\n    });\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "lemma_seq_push_to_set", "function_mode": "proof", "line_start": 141, "line_end": 158, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 7, "is_method": false, "impl_type": null}}
{"id": "task_a_hashmap_t_new_40", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n```\n\nWrite the specifications:", "target_text": "ensures out@ == Map::<AbstractKey, Seq<u8>>::empty(),", "full_function": "\n    #[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n        ensures out@ == Map::<AbstractKey, Seq<u8>>::empty()\n    {\n      CKeyHashMap { m: collections::HashMap::new() }\n    }", "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "new", "function_mode": "exec", "line_start": 34, "line_end": 40, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CKeyHashMap"}}
{"id": "task_a_host_impl_t_next_impl_1", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires(*old(self), *old(netc)),\n        ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }\n```\n\nWrite the specifications:", "target_text": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),", "full_function": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_t.rs", "function_name": "next_impl", "function_mode": "exec", "line_start": 139, "line_end": 146, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_cmessage_v_view_equal_spec_71", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn view_equal_spec()\n```\n\nWrite the specifications:", "target_text": "ensures forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@ { assert forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by { match (x, y) { (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {}, (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {}, (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {}, (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {}, (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {}, (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {}, _ => { assert(!x.view_equal(y) && x@ != y@); } } } } // This would be better if we had a View trait. pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>) ensures match value,\nensures match value,", "full_function": "\n  pub proof fn view_equal_spec()\n    ensures forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@\n  {\n    assert forall |x: &CMessage, y: &CMessage|\n      #[trigger] x.view_equal(y) <==> x@ == y@ by\n    {\n      match (x, y) {\n        (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {},\n        (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {},\n        (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {},\n        (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {},\n        (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {},\n        (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {},\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n  }\n\n  // This would be better if we had a View trait.\n  pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  ensures\n      match value {\n          Some(vec) => {\n              &&& out is Some\n              &&& out.unwrap()@ == vec@\n          }\n          None => {\n              &&& out is None\n          }\n      }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "view_equal_spec", "function_mode": "proof", "line_start": 85, "line_end": 117, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 2, "complexity_score": 4, "is_method": true, "impl_type": "CMessage"}}
{"id": "task_a_delegation_map_v_to_set_114", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn to_set(self) -> (s: Set<K>)\n```\n\nWrite the specifications:", "target_text": "requires self.valid(),\nensures s == self@.to_set(), s.finite(), s.len() == self@.len(),", "full_function": "\n    proof fn to_set(self) -> (s: Set<K>)\n        requires self.valid(),\n        ensures s == self@.to_set(),\n                s.finite(),\n                s.len() == self@.len(),\n    {\n        seq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "to_set", "function_mode": "proof", "line_start": 115, "line_end": 125, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_a_io_t_clone_up_to_view_56", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_up_to_view(&self) -> (res: EndPoint)\n```\n\nWrite the specifications:", "target_text": "ensures res@ == self@,", "full_function": "    pub fn clone_up_to_view(&self) -> (res: EndPoint)\n        ensures res@ == self@\n    {\n        EndPoint{id: clone_vec_u8(&self.id)}\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "clone_up_to_view", "function_mode": "exec", "line_start": 48, "line_end": 52, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "EndPoint"}}
{"id": "task_a_keys_t_cmp_107", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn cmp(&self, other: &Self) -> (o: Ordering)\n//\n```\n\nWrite the specifications:", "target_text": "requires true, //,\nensures o == self.cmp_spec(*other),", "full_function": "\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }", "metadata": {"source_file": "../ironsht/src/keys_t.rs", "function_name": "cmp", "function_mode": "exec", "line_start": 224, "line_end": 236, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": false, "impl_type": null}}
{"id": "task_a_set_lib_ext_v_map_set_finite_auto_164", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn map_set_finite_auto<A, B>()\n```\n\nWrite the specifications:", "target_text": "ensures forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()), { assert forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() implies #[trigger] s.map(f).finite() by { map_finite(s, f); } } pub proof fn lemma_to_set_singleton_auto<A>() ensures forall |x: A| #[trigger] seq![x].to_set() == set![x],\nensures forall |x: A| #[trigger] seq![x].to_set() == set![x],", "full_function": "\npub proof fn map_set_finite_auto<A, B>()\nensures\n    forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()),\n{\n    assert forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() implies #[trigger] s.map(f).finite() by {\n        map_finite(s, f);\n    }\n}\n\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "map_set_finite_auto", "function_mode": "proof", "line_start": 264, "line_end": 281, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 2, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_a_hashmap_t_valid_50", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n```\n\nWrite the specifications:", "target_text": "ensures b == valid_hashtable(self@),", "full_function": "\n    #[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n        ensures b == valid_hashtable(self@)\n    {\n        panic!()\n    }", "metadata": {"source_file": "../ironsht/src/hashmap_t.rs", "function_name": "valid", "function_mode": "exec", "line_start": 159, "line_end": 165, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CKeyHashMap"}}
{"id": "task_a_delegation_map_v_get_143", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get(&self, k: &K) -> (id: ID)\n```\n\nWrite the specifications:", "target_text": "requires self.valid(),\nensures id@ == self@[*k], id@.valid_physical_address(),", "full_function": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "function_mode": "exec", "line_start": 1101, "line_end": 1111, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<K>"}}
{"id": "task_a_seq_lib_v_lemma_subrange_subrange_170", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n```\n\nWrite the specifications:", "target_text": "requires 0 <= start <= s.len(), 0 <= midsize <= endsize <= s.len() - start,\nensures s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),", "full_function": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/seq_lib_v.rs", "function_name": "lemma_subrange_subrange", "function_mode": "proof", "line_start": 4, "line_end": 14, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 5, "is_method": false, "impl_type": null}}
{"id": "task_a_set_lib_ext_v_flatten_sets_spec_154", "task": "code_to_spec", "input_text": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n```\n\nWrite the specifications:", "target_text": "ensures (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)), (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets))) { } pub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>) ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s),\nensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s),", "full_function": "\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    ensures\n        (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}\n\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s)\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}", "metadata": {"source_file": "../ironsht/src/verus_extra/set_lib_ext_v.rs", "function_name": "flatten_sets_spec", "function_mode": "proof", "line_start": 30, "line_end": 42, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 2, "complexity_score": 5, "is_method": false, "impl_type": null}}
