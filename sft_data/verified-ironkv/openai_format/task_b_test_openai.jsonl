{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n    requires 0 <= i <= j <= k <= s.len(), ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n    ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nassert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n    requires self.valid(), self@.contains_key(K::zero_spec()), ensures 0 <= index < self.keys@.len(), self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    ensures 0 <= index < self.keys@.len(), self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<()\n    requires !(old(self).state() is Error) ensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send,\n    ensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\ns: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external)]\n#[verifier(external)]\npub fn get_time_internal(&self) -> (time: u64)\n    requires from_trusted_code(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\n(self.c_pointers.get_time_func)()\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn do_vec_u8s_match(e1: &Vec<u8>, e2: &Vec<u8>) -> (eq: bool)\n    ensures eq == (e1@ == e2@),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nif e1.len() != e2.len() {\n            assert (e1@.len() != e2@.len());\n            assert (e1@ != e2@);\n            return false;\n        }\n\n        let mut i: usize = 0;\n        while i < e1.len()\n            invariant\n                0 <= i,\n                i <= e1.len(),\n                e1.len() == e2.len(),\n                forall |j: int| 0 <= j && j < i ==> e1@[j] == e2@[j]\n            decreases\n                e1.len() - i\n        {\n            if e1[i] != e2[i] {\n                return false;\n            }\n            i += 1;\n        }\n        proof {\n            assert_seqs_equal!(e1@, e2@);\n        }\n        return true;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    requires 0 <= i <= cm.len(), ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i,\n    ensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i), decreases i,\n    decreases i,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nif 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn truncate(&mut self, seqno_acked: u64, Ghost(dst)\n    requires old(self).valid(dst), old(self).num_packets_acked <= seqno_acked, ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\n    ensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn len(&self) -> (len: usize )\n    ensures len == self@.len(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nself.v.len()\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\n    requires x@ == y@, ensures x.is_marshalable() == y.is_marshalable(),\n    ensures x.is_marshalable() == y.is_marshalable(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nCSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn delegate_for_key_range_is_host_impl(&self, lo: &KeyIterator<AbstractKey>, hi: &KeyIterator<AbstractKey>, dst: &ID) -> (b: bool)\n    requires self.valid(), ensures b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange,\n    ensures b == AbstractDelegationMap::delegate_for_key_range_is_host(AbstractDelegationMap(self@), KeyRange,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlo: *lo, hi: *hi\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn endpoints_contain(endpoints: &Vec<EndPoint>, endpoint: &EndPoint) -> (present: bool)\n    ensures present == abstractify_end_points(*endpoints).contains(endpoint@),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet mut j: usize = 0;\n        while j < endpoints.len()\n            invariant\n                0 <= j && j <= endpoints.len(),\n                forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j ==> endpoint@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - j\n        {\n            if do_end_points_match(endpoint, &endpoints[j]) {\n                assert (abstractify_end_points(*endpoints)[j as int] == endpoint@);\n                return true;\n            }\n            j = j + 1;\n        }\n        return false;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nexecfn _is_marshalable(&self) -> bool\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet mut res = true;\n    let mut i = 0;\n    let mut total_len = self.len().serialized_size();\n\n    proof {\n      assert(self@ =~= self@.subrange(0, self@.len() as int));\n    }\n\n    while res && i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        res ==> total_len as int == (self@.len() as usize).ghost_serialize().len() +\n                 self@.subrange(0, i as int).fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()),\n        res ==> (forall |x: T| self@.subrange(0, i as int).contains(x) ==> #[trigger] x.is_marshalable()),\n        res ==> total_len as int <= usize::MAX,\n        !res ==> !self.is_marshalable(),\n      decreases\n        self.len() - i + if res { 1int } else { 0int }\n    {\n      assert(res);\n      res = res && self[i]._is_marshalable() && (usize::MAX - total_len >= self[i].serialized_size());\n      if res {\n        let old_total_len = total_len;\n        total_len = total_len + self[i].serialized_size();\n        i = i + 1;\n        proof {\n          assert forall |x: T| #[trigger] self@.subrange(0, i as int).contains(x) implies x.is_marshalable() by {\n            if (exists |j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x) {\n              let j = choose|j:int| 0 <= j < self@.subrange(0, i as int).len() - 1 && self@.subrange(0, i as int)[j] == x;\n              assert(self@.subrange(0, i as int - 1)[j] == x); // OBSERVE\n            }\n          };\n          let sl = |x: T| x.ghost_serialize().len() as int;\n          assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n          let s = self@.subrange(0 as int, i as int);\n          seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n          assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i - 1 as int));\n        }\n      } else {\n        proof {\n          if usize::MAX < total_len + self@[i as int].ghost_serialize().len() {\n            assert(\n              ((self@.len() as usize).ghost_serialize().len() +\n               self@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()))\n                >=\n              (total_len + self@[i as int].ghost_serialize().len())\n            ) by {\n              let f = |x: T| x.ghost_serialize();\n              let sl = |x: T| x.ghost_serialize().len() as int;\n              let s = self@.subrange(0 as int, i as int + 1);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + sl(x)));\n              seq_lib_v::lemma_seq_fold_left_sum_right::<T>(s, 0, sl);\n              assert(s.subrange(0, s.len() - 1) =~= self@.subrange(0 as int, i as int));\n              seq_lib_v::lemma_seq_fold_left_append_len_int_le(self@, i as int + 1, 0, f);\n              assert((|acc: int, x: T| acc + x.ghost_serialize().len() as int) =~= (|acc: int, x: T| acc + f(x).len()));\n            };\n          } else {\n            assert(!self@[i as int].is_marshalable());\n          }\n        }\n      }\n    }\n\n    res\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n    requires old(self).state() is Receiving ensures self.my_end_point() == old(self).my_end_point(), match result,\n    ensures self.my_end_point() == old(self).my_end_point(), match result,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nNetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn get<'a>(&'a self, key: &EndPoint) -> (value: Option<&'a V>)\n    ensures value == match Self::get_spec(self@, key@),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nSome(v) => Some(&v), None => None\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn view_equal_spec()\n    ensures forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nassert forall |x: &CSingleMessage, y: &CSingleMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by {\n      match (x, y) {\n        (CSingleMessage::Message { seqno: seqno1, dst: dst1, m: m1, },\n        CSingleMessage::Message { seqno: seqno2, dst: dst2, m: m2, }) => {\n          CMessage::view_equal_spec();\n          assert(seqno1.view_equal(seqno2) <==> seqno1 == seqno2);\n          assert(dst1.view_equal(dst2) <==> dst1@ == dst2@);\n          assert(m1.view_equal(m2) <==> m1@ == m2@);\n        }\n        (CSingleMessage::InvalidMessage {  }, CSingleMessage::InvalidMessage {  }) => {}\n        (CSingleMessage::Ack { ack_seqno: x1 }, CSingleMessage::Ack { ack_seqno: x2 }) => {}\n        _ => {\n          assert(!x.view_equal(y) && x@ != y@);\n        }\n      }\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n    requires self.valid(dst), 0 <= k < self.un_acked@.len(), ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k,\n    ensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1 decreases k,\n    decreases k,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nif k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n    ensures cloned_ep@ == ep@,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nEndPoint{id: clone_vec_u8(&ep.id)}\n}"}]}
