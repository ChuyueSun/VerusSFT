{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_to_set_union_auto<A>()\n    ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nassert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n    requires old(self).next_set_request_preconditions(),\n    ensures self.next_set_request_postconditions(*old(self), sent_packets@),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nproof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nassert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn new() -> (out: CKeyHashMap)\n    ensures out@ == Map::<AbstractKey, Seq<u8>>::empty(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nCKeyHashMap { m: collections::HashMap::new() }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID)\n    requires self.range_consistent(x, y, dst), x_inner.geq_spec(*x), !y.lt_spec(*y_inner),\n    ensures self.range_consistent(x_inner, y_inner, dst),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nK::cmp_properties();\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n    requires pre.valid(), post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\n    ensures AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlo: *lo, hi: *hi\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==> exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)), (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==> flatten_set_seq(sets).contains(x)),\n    decreases sets.len(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nif sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier::external_body]\npub fn len(&self) -> (l: usize)\n    ensures l as int == self@.len(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nself.m.len()\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>)\n    requires Self::next_requires(*old(self), *old(netc)),\n    ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nself.real_next_impl(netc)\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn clone_up_to_view(&self) -> (c: Self)\n    ensures c@ == self@,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nmatch self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn insert(&mut self, k: K) -> (i: usize)\n    requires old(self).valid(), !old(self)@.contains(k),\n    ensures self.valid(), self@.len() == old(self)@.len() + 1, 0 <= i < self@.len(), self@ == old(self)@.insert(i as int, k), self@.to_set() == old(self)@.to_set().insert(k),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\n// Find the index where we should insert k\n        let mut index: usize = 0;\n        while index < self.v.len() && self.v[index].cmp(&k).is_lt()\n            invariant\n                0 <= index <= self@.len(),\n                forall |i| 0 <= i < index ==> (#[trigger] self@.index(i).cmp_spec(k)).lt()\n            decreases\n               self@.len() - index\n        {\n            index = index + 1;\n        }\n        self.v.insert(index, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n        assert(self@.to_set() == old(self)@.to_set().insert(k)) by {\n            let new_s = self@.to_set();\n            let old_s = old(self)@.to_set().insert(k);\n            assert(self@[index as int] == k);   // OBSERVE\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                if e == k {\n                } else {\n                    let i = choose |i: int| 0 <= i < old(self)@.len() && old(self)@[i] == e;\n                    if i < index {\n                        assert(self@[i] == e);      // OBSERVE\n                    } else {\n                        assert(self@[i+1] == e);    // OBSERVE\n                    }\n                }\n            };\n            assert_sets_equal!(new_s, old_s);\n        };\n        return index;\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn get_time(&mut self) -> (time: u64)\n    requires old(self).state() is Receiving,\n    ensures (,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\n&&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn to_set(self) -> (s: Set<K>)\n    requires self.valid(),\n    ensures s == self@.to_set(), s.finite(), s.len() == self@.len(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nseq_to_set_is_finite::<K>(self@);\n        self@.unique_seq_to_set();\n        self@.to_set()\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n    ensures (s+t).to_set() == s.to_set() + t.to_set(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>)\n    requires old(netc).ok(), outbound_packet_seq_is_valid(cpackets@), outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\n    ensures netc.my_end_point() == old(netc).my_end_point(), (,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n}"}]}
