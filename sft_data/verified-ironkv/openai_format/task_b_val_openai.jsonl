{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    ensures value == match HashMap::get_spec(self.epmap@, src@),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nSome(v) => Some(&v), None => None\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn put(&mut self, src: &EndPoint, value: CAckState)\n    ensures HashMap::put_spec(old(self).epmap@, self.epmap@, src@, value),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nself.epmap.put(src, value)\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n    requires old(self).next_set_request_preconditions() ensures self.next_set_request_postconditions(*old(self), sent_packets@),\n    ensures self.next_set_request_postconditions(*old(self), sent_packets@),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nproof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nassert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn new() -> (out: CKeyHashMap)\n    ensures out@ == Map::<AbstractKey, Seq<u8>>::empty(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nCKeyHashMap { m: collections::HashMap::new() }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID)\n    requires self.range_consistent(x, y, dst), x_inner.geq_spec(*x), !y.lt_spec(*y_inner), ensures self.range_consistent(x_inner, y_inner, dst),\n    ensures self.range_consistent(x_inner, y_inner, dst),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nK::cmp_properties();\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nprooffn effect_of_delegation_map_set(\n        pre: DelegationMap<CKey>,\n        post: DelegationMap<CKey>,\n        lo: &KeyIterator<CKey>,\n        hi: &KeyIterator<CKey>,\n        dst: &EndPoint\n    )\n    requires pre.valid(), post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi)) ==> post@[*ki.get()] == pre@[*ki.get()], ensures AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>,\n    ensures AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(KeyRange::<AbstractKey>,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlo: *lo, hi: *hi\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub prooffn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==> exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)), (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==> flatten_set_seq(sets).contains(x)) decreases sets.len(),\n    decreases sets.len(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nif sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier::external_body]\npub fn len(&self) -> (l: usize)\n    ensures l as int == self@.len(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nself.m.len()\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>)\n    requires Self::next_requires(*old(self), *old(netc)), ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    ensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nself.real_next_impl(netc)\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn clone_up_to_view(&self) -> (c: Self)\n    ensures c@ == self@,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nmatch self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn new(k: K) -> (s: Self)\n    ensures s.k == Some(k),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nKeyIterator { k: Some(k) }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\n#[verifier(external_body)]\n#[verifier(external_body)]\npub fn get_time(&mut self) -> (time: u64)\n    requires old(self).state() is Receiving ensures (,\n    ensures (,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\n&&& self.state() is Sending\n            &&& self.history() == old(self).history() + seq![LIoOp::ReadClock{t: time as int}]\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\nfn new() -> (v: Self)\n    ensures v@ == Seq::<K>::empty(), v.valid(),\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nStrictlyOrderedVec { v: Vec::new() }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function signature with specifications, implement the function body including any necessary ghost code and proof blocks to make it verify."}, {"role": "user", "content": "Given the following Verus function signature and specifications, implement the function body.\n\nSignature and Specs:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>)\n    requires old(netc).ok(), outbound_packet_seq_is_valid(cpackets@), outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()), ensures netc.my_end_point() == old(netc).my_end_point(), (,\n    ensures netc.my_end_point() == old(netc).my_end_point(), (,\n```\n\nImplement the function body:"}, {"role": "assistant", "content": "{\nlet (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n}"}]}
