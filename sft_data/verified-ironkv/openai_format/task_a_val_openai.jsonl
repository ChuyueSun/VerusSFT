{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires old(netc).ok(), outbound_packet_seq_is_valid(packets@), outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\nensures netc.my_end_point() == old(netc).my_end_point(), (,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_flatten_sets_union_auto<A>()\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>| #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nexec fn deserialize(data: &Vec<u8>, start: usize) -> (res: Option<(Self, usize)>)\n    // req, ens from trait\n  {\n    let (len, mid) = match usize::deserialize(data, start) { None => {\n      return None;\n    }, Some(x) => x, };\n    let len = len as usize;\n\n    let mut res: Vec<T> = Vec::with_capacity(len);\n    let mut i: usize = 0;\n    let mut end = mid;\n\n    let emp: Ghost<Seq<u8>> = Ghost(Seq::<u8>::empty());\n    let accf: Ghost<spec_fn(Seq<u8>, T) -> Seq<u8>> = Ghost(|acc: Seq<u8>, x: T| acc + x.ghost_serialize());\n\n    proof {\n      assert(data@.subrange(mid as int, end as int) =~= emp@);\n      // assert(emp == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n\n      lemma_auto_spec_u64_to_from_le_bytes();\n    }\n\n    while i < len\n      decreases\n        len - i\n    {\n      let (x, end1) = match T::deserialize(data, end) { None => {\n        return None;\n      }, Some(x) => x, };\n\n      let old_end: Ghost<int> = Ghost(end as int);\n      let old_res: Ghost<Seq<T>> = Ghost(res@);\n\n      res.push(x);\n      end = end1;\n      i = i + 1;\n\n      assert(data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@)) by {\n        let f = |x: T| x.ghost_serialize();\n        // assert(data@.subrange(mid as int, old_end@) == seq_lib_v::seq_fold_left(old_res@, emp@, accf@));\n        seq_lib_v::lemma_seq_add_subrange::<u8>(data@, mid as int, old_end@, end as int);\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + data@.subrange(old_end@, end as int));\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + x.ghost_serialize());\n        // assert(f(x) == x.ghost_serialize());\n        // assert(data@.subrange(mid as int, end as int) ==\n        //        seq_lib_v::seq_fold_left(old_res@, emp@, accf@) + f(x));\n        seq_lib_v::lemma_seq_fold_left_append_right(res@, emp@, f);\n        assert(accf@ == (|acc: Seq<u8>, x: T| acc + f(x))) by {\n          assert(accf@ =~= (|acc: Seq<u8>, x: T| acc + f(x)));\n        }\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n        // assert(data@.subrange(mid as int, end as int) == seq_lib_v::seq_fold_left(res@, emp@, accf@));\n      }\n\n      assert (len.ghost_serialize().len() +\n              res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start) by {\n        let l = |x: T| x.ghost_serialize().len() as int;\n        let suml = |acc: int, x: T| acc + l(x);\n        seq_lib_v::lemma_seq_fold_left_sum_right(res@, 0, l);\n        assert((|acc: int, x: T| acc + x.ghost_serialize().len()) =~= suml);\n        assert(old_res@ =~= res@.subrange(0, res@.len() - 1));\n      }\n\n      assert (len.ghost_serialize().len() == (res@.len() as usize).ghost_serialize().len()) by {\n        lemma_auto_spec_u64_to_from_le_bytes();\n      }\n    }\n    assert(data@.subrange(start as int, end as int) == res.ghost_serialize()) by {\n      seq_lib_v::lemma_seq_add_subrange::<u8>(data@, start as int, mid as int, end as int);\n    }\n\n    Some((res, end))\n  }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "invariant 0 <= i <= len, res.is_marshalable(), start <= mid <= end <= data@.len(), data@.subrange(mid as int, end as int) == res@.fold_left(emp@, accf@), res@.len() == i, len.ghost_serialize().len() + res@.fold_left(0, |acc: int, x: T| acc + x.ghost_serialize().len()) == end - start, accf@ == |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn range_consistent_subset(self, x: &KeyIterator<K>, y: &KeyIterator<K>, x_inner: &KeyIterator<K>, y_inner: &KeyIterator<K>, dst: &ID)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires self.range_consistent(x, y, dst), x_inner.geq_spec(*x), !y.lt_spec(*y_inner),\nensures self.range_consistent(x_inner, y_inner, dst),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires(*old(self), *old(netc)),\n    ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures s.push(x).to_set() == s.to_set().insert(x),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn new() -> (out: CKeyHashMap)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures out@ == Map::<AbstractKey, Seq<u8>>::empty(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires(*old(self), *old(netc)),\n        ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn view_equal_spec()\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@ { assert forall |x: &CMessage, y: &CMessage| #[trigger] x.view_equal(y) <==> x@ == y@ by { match (x, y) { (CMessage::GetRequest { k: k1 }, CMessage::GetRequest { k: k2 }) => {}, (CMessage::SetRequest { k: k1, v: v1 }, CMessage::SetRequest { k: k2, v: v2 }) => {}, (CMessage::Reply { k: k1, v: v1 }, CMessage::Reply { k: k2, v: v2 }) => {}, (CMessage::Redirect { k: k1, id: id1 }, CMessage::Redirect { k: k2, id: id2 }) => {}, (CMessage::Shard { kr: kr1, recipient: r1 }, CMessage::Shard { kr: kr2, recipient: r2 }) => {}, (CMessage::Delegate { range: r1, h: h1 }, CMessage::Delegate { range: r2, h: h2 }) => {}, _ => { assert(!x.view_equal(y) && x@ != y@); } } } } // This would be better if we had a View trait. pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>) ensures match value,\nensures match value,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn to_set(self) -> (s: Set<K>)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires self.valid(),\nensures s == self@.to_set(), s.finite(), s.len() == self@.len(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_up_to_view(&self) -> (res: EndPoint)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures res@ == self@,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn cmp(&self, other: &Self) -> (o: Ordering)\n//\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires true, //,\nensures o == self.cmp_spec(*other),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn map_set_finite_auto<A, B>()\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()), { assert forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() implies #[trigger] s.map(f).finite() by { map_finite(s, f); } } pub proof fn lemma_to_set_singleton_auto<A>() ensures forall |x: A| #[trigger] seq![x].to_set() == set![x],\nensures forall |x: A| #[trigger] seq![x].to_set() == set![x],"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn valid(&self) -> (b: bool)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures b == valid_hashtable(self@),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get(&self, k: &K) -> (id: ID)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires self.valid(),\nensures id@ == self@[*k], id@.valid_physical_address(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires 0 <= start <= s.len(), 0 <= midsize <= endsize <= s.len() - start,\nensures s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function, write the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)), (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets))) { } pub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>) ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s),\nensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s),"}]}
